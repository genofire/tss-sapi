/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201605;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const TSS2_RC_LEVEL_SHIFT: ::std::os::raw::c_uint = 16;
pub const TSS2_BASE_RC_GENERAL_FAILURE: ::std::os::raw::c_uint = 1;
pub const TSS2_BASE_RC_NOT_IMPLEMENTED: ::std::os::raw::c_uint = 2;
pub const TSS2_BASE_RC_BAD_CONTEXT: ::std::os::raw::c_uint = 3;
pub const TSS2_BASE_RC_ABI_MISMATCH: ::std::os::raw::c_uint = 4;
pub const TSS2_BASE_RC_BAD_REFERENCE: ::std::os::raw::c_uint = 5;
pub const TSS2_BASE_RC_INSUFFICIENT_BUFFER: ::std::os::raw::c_uint = 6;
pub const TSS2_BASE_RC_BAD_SEQUENCE: ::std::os::raw::c_uint = 7;
pub const TSS2_BASE_RC_NO_CONNECTION: ::std::os::raw::c_uint = 8;
pub const TSS2_BASE_RC_TRY_AGAIN: ::std::os::raw::c_uint = 9;
pub const TSS2_BASE_RC_IO_ERROR: ::std::os::raw::c_uint = 10;
pub const TSS2_BASE_RC_BAD_VALUE: ::std::os::raw::c_uint = 11;
pub const TSS2_BASE_RC_NOT_PERMITTED: ::std::os::raw::c_uint = 12;
pub const TSS2_BASE_RC_INVALID_SESSIONS: ::std::os::raw::c_uint = 13;
pub const TSS2_BASE_RC_NO_DECRYPT_PARAM: ::std::os::raw::c_uint = 14;
pub const TSS2_BASE_RC_NO_ENCRYPT_PARAM: ::std::os::raw::c_uint = 15;
pub const TSS2_BASE_RC_BAD_SIZE: ::std::os::raw::c_uint = 16;
pub const TSS2_BASE_RC_MALFORMED_RESPONSE: ::std::os::raw::c_uint = 17;
pub const TSS2_BASE_RC_INSUFFICIENT_CONTEXT: ::std::os::raw::c_uint = 18;
pub const TSS2_BASE_RC_INSUFFICIENT_RESPONSE: ::std::os::raw::c_uint = 19;
pub const TSS2_BASE_RC_INCOMPATIBLE_TCTI: ::std::os::raw::c_uint = 20;
pub const TSS2_BASE_RC_NOT_SUPPORTED: ::std::os::raw::c_uint = 21;
pub const TSS2_BASE_RC_BAD_TCTI_STRUCTURE: ::std::os::raw::c_uint = 22;
pub const TSS2_LEVEL_IMPLEMENTATION_SPECIFIC_SHIFT: ::std::os::raw::c_uint =
    11;
pub const TSS2_LEVEL_IMPLEMENTATION_SPECIFIC_OFFSET: ::std::os::raw::c_uint =
    63488;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const YES: ::std::os::raw::c_uint = 1;
pub const NO: ::std::os::raw::c_uint = 0;
pub const SET: ::std::os::raw::c_uint = 1;
pub const CLEAR: ::std::os::raw::c_uint = 0;
pub const BIG_ENDIAN_TPM: ::std::os::raw::c_uint = 0;
pub const LITTLE_ENDIAN_TPM: ::std::os::raw::c_uint = 1;
pub const NO_AUTO_ALIGN: ::std::os::raw::c_uint = 0;
pub const MAX_RSA_KEY_BITS: ::std::os::raw::c_uint = 2048;
pub const MAX_RSA_KEY_BYTES: ::std::os::raw::c_uint = 256;
pub const MAX_AES_KEY_BITS: ::std::os::raw::c_uint = 256;
pub const MAX_AES_KEY_BYTES: ::std::os::raw::c_uint = 32;
pub const MAX_SM4_KEY_BITS: ::std::os::raw::c_uint = 128;
pub const MAX_SM4_KEY_BYTES: ::std::os::raw::c_uint = 16;
pub const MAX_CAMELLIA_KEY_BITS: ::std::os::raw::c_uint = 128;
pub const MAX_CAMELLIA_KEY_BYTES: ::std::os::raw::c_uint = 16;
pub const ECC_NIST_P256: ::std::os::raw::c_uint = 1;
pub const ECC_NIST_P384: ::std::os::raw::c_uint = 1;
pub const ECC_BN_P256: ::std::os::raw::c_uint = 1;
pub const MAX_ECC_KEY_BITS: ::std::os::raw::c_uint = 384;
pub const MAX_ECC_KEY_BYTES: ::std::os::raw::c_uint = 48;
pub const FIELD_UPGRADE_IMPLEMENTED: ::std::os::raw::c_uint = 0;
pub const BUFFER_ALIGNMENT: ::std::os::raw::c_uint = 4;
pub const IMPLEMENTATION_PCR: ::std::os::raw::c_uint = 24;
pub const PLATFORM_PCR: ::std::os::raw::c_uint = 24;
pub const DRTM_PCR: ::std::os::raw::c_uint = 17;
pub const HCRTM_PCR: ::std::os::raw::c_uint = 0;
pub const NUM_LOCALITIES: ::std::os::raw::c_uint = 5;
pub const MAX_HANDLE_NUM: ::std::os::raw::c_uint = 3;
pub const MAX_ACTIVE_SESSIONS: ::std::os::raw::c_uint = 64;
pub const MAX_LOADED_SESSIONS: ::std::os::raw::c_uint = 3;
pub const MAX_SESSION_NUM: ::std::os::raw::c_uint = 3;
pub const MAX_LOADED_OBJECTS: ::std::os::raw::c_uint = 3;
pub const MIN_EVICT_OBJECTS: ::std::os::raw::c_uint = 2;
pub const PCR_SELECT_MIN: ::std::os::raw::c_uint = 3;
pub const PCR_SELECT_MAX: ::std::os::raw::c_uint = 3;
pub const NUM_POLICY_PCR_GROUP: ::std::os::raw::c_uint = 1;
pub const NUM_AUTHVALUE_PCR_GROUP: ::std::os::raw::c_uint = 1;
pub const MAX_CONTEXT_SIZE: ::std::os::raw::c_uint = 2048;
pub const MAX_DIGEST_BUFFER: ::std::os::raw::c_uint = 1024;
pub const MAX_NV_INDEX_SIZE: ::std::os::raw::c_uint = 2048;
pub const MAX_NV_BUFFER_SIZE: ::std::os::raw::c_uint = 1024;
pub const MAX_CAP_BUFFER: ::std::os::raw::c_uint = 1024;
pub const NV_MEMORY_SIZE: ::std::os::raw::c_uint = 16384;
pub const NUM_STATIC_PCR: ::std::os::raw::c_uint = 16;
pub const MAX_ALG_LIST_SIZE: ::std::os::raw::c_uint = 64;
pub const TIMER_PRESCALE: ::std::os::raw::c_uint = 100000;
pub const PRIMARY_SEED_SIZE: ::std::os::raw::c_uint = 32;
pub const NV_CLOCK_UPDATE_INTERVAL: ::std::os::raw::c_uint = 12;
pub const NUM_POLICY_PCR: ::std::os::raw::c_uint = 1;
pub const MAX_COMMAND_SIZE: ::std::os::raw::c_uint = 4096;
pub const MAX_RESPONSE_SIZE: ::std::os::raw::c_uint = 4096;
pub const ORDERLY_BITS: ::std::os::raw::c_uint = 8;
pub const MAX_ORDERLY_COUNT: ::std::os::raw::c_uint = 255;
pub const MAX_SYM_DATA: ::std::os::raw::c_uint = 128;
pub const MAX_RNG_ENTROPY_SIZE: ::std::os::raw::c_uint = 64;
pub const RAM_INDEX_SPACE: ::std::os::raw::c_uint = 512;
pub const RSA_DEFAULT_PUBLIC_EXPONENT: ::std::os::raw::c_uint = 65537;
pub const ENABLE_PCR_NO_INCREMENT: ::std::os::raw::c_uint = 1;
pub const CRT_FORMAT_RSA: ::std::os::raw::c_uint = 1;
pub const VENDOR_COMMAND_COUNT: ::std::os::raw::c_uint = 0;
pub const PRIVATE_VENDOR_SPECIFIC_BYTES: ::std::os::raw::c_uint = 640;
pub const MAX_VENDOR_BUFFER_SIZE: ::std::os::raw::c_uint = 1024;
pub const ALG_ERROR_VALUE: ::std::os::raw::c_uint = 0;
pub const ALG_RSA_VALUE: ::std::os::raw::c_uint = 1;
pub const ALG_SHA_VALUE: ::std::os::raw::c_uint = 4;
pub const ALG_SHA1_VALUE: ::std::os::raw::c_uint = 4;
pub const ALG_HMAC_VALUE: ::std::os::raw::c_uint = 5;
pub const ALG_AES_VALUE: ::std::os::raw::c_uint = 6;
pub const ALG_MGF1_VALUE: ::std::os::raw::c_uint = 7;
pub const ALG_KEYEDHASH_VALUE: ::std::os::raw::c_uint = 8;
pub const ALG_XOR_VALUE: ::std::os::raw::c_uint = 10;
pub const ALG_SHA256_VALUE: ::std::os::raw::c_uint = 11;
pub const ALG_SHA384_VALUE: ::std::os::raw::c_uint = 12;
pub const ALG_SHA512_VALUE: ::std::os::raw::c_uint = 13;
pub const ALG_NULL_VALUE: ::std::os::raw::c_uint = 16;
pub const ALG_SM3_256_VALUE: ::std::os::raw::c_uint = 18;
pub const ALG_SM4_VALUE: ::std::os::raw::c_uint = 19;
pub const ALG_RSASSA_VALUE: ::std::os::raw::c_uint = 20;
pub const ALG_RSAES_VALUE: ::std::os::raw::c_uint = 21;
pub const ALG_RSAPSS_VALUE: ::std::os::raw::c_uint = 22;
pub const ALG_OAEP_VALUE: ::std::os::raw::c_uint = 23;
pub const ALG_ECDSA_VALUE: ::std::os::raw::c_uint = 24;
pub const ALG_ECDH_VALUE: ::std::os::raw::c_uint = 25;
pub const ALG_ECDAA_VALUE: ::std::os::raw::c_uint = 26;
pub const ALG_SM2_VALUE: ::std::os::raw::c_uint = 27;
pub const ALG_ECSCHNORR_VALUE: ::std::os::raw::c_uint = 28;
pub const ALG_ECMQV_VALUE: ::std::os::raw::c_uint = 29;
pub const ALG_KDF1_SP800_56A_VALUE: ::std::os::raw::c_uint = 32;
pub const ALG_KDF2_VALUE: ::std::os::raw::c_uint = 33;
pub const ALG_KDF1_SP800_108_VALUE: ::std::os::raw::c_uint = 34;
pub const ALG_ECC_VALUE: ::std::os::raw::c_uint = 35;
pub const ALG_SYMCIPHER_VALUE: ::std::os::raw::c_uint = 37;
pub const ALG_CAMELLIA_VALUE: ::std::os::raw::c_uint = 38;
pub const ALG_CTR_VALUE: ::std::os::raw::c_uint = 64;
pub const ALG_OFB_VALUE: ::std::os::raw::c_uint = 65;
pub const ALG_CBC_VALUE: ::std::os::raw::c_uint = 66;
pub const ALG_CFB_VALUE: ::std::os::raw::c_uint = 67;
pub const ALG_ECB_VALUE: ::std::os::raw::c_uint = 68;
pub const ALG_FIRST_VALUE: ::std::os::raw::c_uint = 1;
pub const ALG_LAST_VALUE: ::std::os::raw::c_uint = 68;
pub const SHA1_DIGEST_SIZE: ::std::os::raw::c_uint = 20;
pub const SHA1_BLOCK_SIZE: ::std::os::raw::c_uint = 64;
pub const SHA1_DER_SIZE: ::std::os::raw::c_uint = 15;
pub const SHA256_DIGEST_SIZE: ::std::os::raw::c_uint = 32;
pub const SHA256_BLOCK_SIZE: ::std::os::raw::c_uint = 64;
pub const SHA256_DER_SIZE: ::std::os::raw::c_uint = 19;
pub const SHA384_DIGEST_SIZE: ::std::os::raw::c_uint = 48;
pub const SHA384_BLOCK_SIZE: ::std::os::raw::c_uint = 128;
pub const SHA384_DER_SIZE: ::std::os::raw::c_uint = 19;
pub const SHA512_DIGEST_SIZE: ::std::os::raw::c_uint = 64;
pub const SHA512_BLOCK_SIZE: ::std::os::raw::c_uint = 128;
pub const SHA512_DER_SIZE: ::std::os::raw::c_uint = 19;
pub const SM3_256_DIGEST_SIZE: ::std::os::raw::c_uint = 32;
pub const SM3_256_BLOCK_SIZE: ::std::os::raw::c_uint = 64;
pub const SM3_256_DER_SIZE: ::std::os::raw::c_uint = 18;
pub const AES_ALLOWED_KEY_SIZE_128: ::std::os::raw::c_uint = 1;
pub const AES_ALLOWED_KEY_SIZE_192: ::std::os::raw::c_uint = 1;
pub const AES_ALLOWED_KEY_SIZE_256: ::std::os::raw::c_uint = 1;
pub const AES_128_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const AES_192_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const AES_256_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const SM4_ALLOWED_KEY_SIZE_128: ::std::os::raw::c_uint = 1;
pub const SM4_128_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const CAMELLIA_ALLOWED_KEY_SIZE_128: ::std::os::raw::c_uint = 1;
pub const CAMELLIA_ALLOWED_KEY_SIZE_192: ::std::os::raw::c_uint = 1;
pub const CAMELLIA_ALLOWED_KEY_SIZE_256: ::std::os::raw::c_uint = 1;
pub const CAMELLIA_128_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const CAMELLIA_192_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const CAMELLIA_256_BLOCK_SIZE_BYTES: ::std::os::raw::c_uint = 16;
pub const ADD_FILL: ::std::os::raw::c_uint = 1;
pub const ALG_CAMELLIA: ::std::os::raw::c_uint = 0;
pub const MAX_CAP_ALGS: ::std::os::raw::c_uint = 68;
pub const TPM_SPEC_FAMILY: ::std::os::raw::c_uint = 841887744;
pub const TPM_SPEC_LEVEL: ::std::os::raw::c_uint = 0;
pub const TPM_SPEC_VERSION: ::std::os::raw::c_uint = 126;
pub const TPM_SPEC_YEAR: ::std::os::raw::c_uint = 2015;
pub const TPM_SPEC_DAY_OF_YEAR: ::std::os::raw::c_uint = 233;
pub const TPM_GENERATED_VALUE: ::std::os::raw::c_uint = 4283712327;
pub const TPM_RC_SUCCESS: ::std::os::raw::c_uint = 0;
pub const TPM_RC_BAD_TAG: ::std::os::raw::c_uint = 30;
pub const RC_VER1: ::std::os::raw::c_uint = 256;
pub const TPM_RC_INITIALIZE: ::std::os::raw::c_uint = 256;
pub const TPM_RC_FAILURE: ::std::os::raw::c_uint = 257;
pub const TPM_RC_SEQUENCE: ::std::os::raw::c_uint = 259;
pub const TPM_RC_PRIVATE: ::std::os::raw::c_uint = 267;
pub const TPM_RC_HMAC: ::std::os::raw::c_uint = 281;
pub const TPM_RC_DISABLED: ::std::os::raw::c_uint = 288;
pub const TPM_RC_EXCLUSIVE: ::std::os::raw::c_uint = 289;
pub const TPM_RC_AUTH_TYPE: ::std::os::raw::c_uint = 292;
pub const TPM_RC_AUTH_MISSING: ::std::os::raw::c_uint = 293;
pub const TPM_RC_POLICY: ::std::os::raw::c_uint = 294;
pub const TPM_RC_PCR: ::std::os::raw::c_uint = 295;
pub const TPM_RC_PCR_CHANGED: ::std::os::raw::c_uint = 296;
pub const TPM_RC_UPGRADE: ::std::os::raw::c_uint = 301;
pub const TPM_RC_TOO_MANY_CONTEXTS: ::std::os::raw::c_uint = 302;
pub const TPM_RC_AUTH_UNAVAILABLE: ::std::os::raw::c_uint = 303;
pub const TPM_RC_REBOOT: ::std::os::raw::c_uint = 304;
pub const TPM_RC_UNBALANCED: ::std::os::raw::c_uint = 305;
pub const TPM_RC_COMMAND_SIZE: ::std::os::raw::c_uint = 322;
pub const TPM_RC_COMMAND_CODE: ::std::os::raw::c_uint = 323;
pub const TPM_RC_AUTHSIZE: ::std::os::raw::c_uint = 324;
pub const TPM_RC_AUTH_CONTEXT: ::std::os::raw::c_uint = 325;
pub const TPM_RC_NV_RANGE: ::std::os::raw::c_uint = 326;
pub const TPM_RC_NV_SIZE: ::std::os::raw::c_uint = 327;
pub const TPM_RC_NV_LOCKED: ::std::os::raw::c_uint = 328;
pub const TPM_RC_NV_AUTHORIZATION: ::std::os::raw::c_uint = 329;
pub const TPM_RC_NV_UNINITIALIZED: ::std::os::raw::c_uint = 330;
pub const TPM_RC_NV_SPACE: ::std::os::raw::c_uint = 331;
pub const TPM_RC_NV_DEFINED: ::std::os::raw::c_uint = 332;
pub const TPM_RC_BAD_CONTEXT: ::std::os::raw::c_uint = 336;
pub const TPM_RC_CPHASH: ::std::os::raw::c_uint = 337;
pub const TPM_RC_PARENT: ::std::os::raw::c_uint = 338;
pub const TPM_RC_NEEDS_TEST: ::std::os::raw::c_uint = 339;
pub const TPM_RC_NO_RESULT: ::std::os::raw::c_uint = 340;
pub const TPM_RC_SENSITIVE: ::std::os::raw::c_uint = 341;
pub const RC_MAX_FM0: ::std::os::raw::c_uint = 383;
pub const RC_FMT1: ::std::os::raw::c_uint = 128;
pub const TPM_RC_ASYMMETRIC: ::std::os::raw::c_uint = 129;
pub const TPM_RC_ATTRIBUTES: ::std::os::raw::c_uint = 130;
pub const TPM_RC_HASH: ::std::os::raw::c_uint = 131;
pub const TPM_RC_VALUE: ::std::os::raw::c_uint = 132;
pub const TPM_RC_HIERARCHY: ::std::os::raw::c_uint = 133;
pub const TPM_RC_KEY_SIZE: ::std::os::raw::c_uint = 135;
pub const TPM_RC_MGF: ::std::os::raw::c_uint = 136;
pub const TPM_RC_MODE: ::std::os::raw::c_uint = 137;
pub const TPM_RC_TYPE: ::std::os::raw::c_uint = 138;
pub const TPM_RC_HANDLE: ::std::os::raw::c_uint = 139;
pub const TPM_RC_KDF: ::std::os::raw::c_uint = 140;
pub const TPM_RC_RANGE: ::std::os::raw::c_uint = 141;
pub const TPM_RC_AUTH_FAIL: ::std::os::raw::c_uint = 142;
pub const TPM_RC_NONCE: ::std::os::raw::c_uint = 143;
pub const TPM_RC_PP: ::std::os::raw::c_uint = 144;
pub const TPM_RC_SCHEME: ::std::os::raw::c_uint = 146;
pub const TPM_RC_SIZE: ::std::os::raw::c_uint = 149;
pub const TPM_RC_SYMMETRIC: ::std::os::raw::c_uint = 150;
pub const TPM_RC_TAG: ::std::os::raw::c_uint = 151;
pub const TPM_RC_SELECTOR: ::std::os::raw::c_uint = 152;
pub const TPM_RC_INSUFFICIENT: ::std::os::raw::c_uint = 154;
pub const TPM_RC_SIGNATURE: ::std::os::raw::c_uint = 155;
pub const TPM_RC_KEY: ::std::os::raw::c_uint = 156;
pub const TPM_RC_POLICY_FAIL: ::std::os::raw::c_uint = 157;
pub const TPM_RC_INTEGRITY: ::std::os::raw::c_uint = 159;
pub const TPM_RC_TICKET: ::std::os::raw::c_uint = 160;
pub const TPM_RC_RESERVED_BITS: ::std::os::raw::c_uint = 161;
pub const TPM_RC_BAD_AUTH: ::std::os::raw::c_uint = 162;
pub const TPM_RC_EXPIRED: ::std::os::raw::c_uint = 163;
pub const TPM_RC_POLICY_CC: ::std::os::raw::c_uint = 164;
pub const TPM_RC_BINDING: ::std::os::raw::c_uint = 165;
pub const TPM_RC_CURVE: ::std::os::raw::c_uint = 166;
pub const TPM_RC_ECC_POINT: ::std::os::raw::c_uint = 167;
pub const RC_WARN: ::std::os::raw::c_uint = 2304;
pub const TPM_RC_CONTEXT_GAP: ::std::os::raw::c_uint = 2305;
pub const TPM_RC_OBJECT_MEMORY: ::std::os::raw::c_uint = 2306;
pub const TPM_RC_SESSION_MEMORY: ::std::os::raw::c_uint = 2307;
pub const TPM_RC_MEMORY: ::std::os::raw::c_uint = 2308;
pub const TPM_RC_SESSION_HANDLES: ::std::os::raw::c_uint = 2309;
pub const TPM_RC_OBJECT_HANDLES: ::std::os::raw::c_uint = 2310;
pub const TPM_RC_LOCALITY: ::std::os::raw::c_uint = 2311;
pub const TPM_RC_YIELDED: ::std::os::raw::c_uint = 2312;
pub const TPM_RC_CANCELED: ::std::os::raw::c_uint = 2313;
pub const TPM_RC_TESTING: ::std::os::raw::c_uint = 2314;
pub const TPM_RC_REFERENCE_H0: ::std::os::raw::c_uint = 2320;
pub const TPM_RC_REFERENCE_H1: ::std::os::raw::c_uint = 2321;
pub const TPM_RC_REFERENCE_H2: ::std::os::raw::c_uint = 2322;
pub const TPM_RC_REFERENCE_H3: ::std::os::raw::c_uint = 2323;
pub const TPM_RC_REFERENCE_H4: ::std::os::raw::c_uint = 2324;
pub const TPM_RC_REFERENCE_H5: ::std::os::raw::c_uint = 2325;
pub const TPM_RC_REFERENCE_H6: ::std::os::raw::c_uint = 2326;
pub const TPM_RC_REFERENCE_S0: ::std::os::raw::c_uint = 2328;
pub const TPM_RC_REFERENCE_S1: ::std::os::raw::c_uint = 2329;
pub const TPM_RC_REFERENCE_S2: ::std::os::raw::c_uint = 2330;
pub const TPM_RC_REFERENCE_S3: ::std::os::raw::c_uint = 2331;
pub const TPM_RC_REFERENCE_S4: ::std::os::raw::c_uint = 2332;
pub const TPM_RC_REFERENCE_S5: ::std::os::raw::c_uint = 2333;
pub const TPM_RC_REFERENCE_S6: ::std::os::raw::c_uint = 2334;
pub const TPM_RC_NV_RATE: ::std::os::raw::c_uint = 2336;
pub const TPM_RC_LOCKOUT: ::std::os::raw::c_uint = 2337;
pub const TPM_RC_RETRY: ::std::os::raw::c_uint = 2338;
pub const TPM_RC_NV_UNAVAILABLE: ::std::os::raw::c_uint = 2339;
pub const TPM_RC_NOT_USED: ::std::os::raw::c_uint = 2431;
pub const TPM_RC_H: ::std::os::raw::c_uint = 0;
pub const TPM_RC_P: ::std::os::raw::c_uint = 64;
pub const TPM_RC_S: ::std::os::raw::c_uint = 2048;
pub const TPM_RC_1: ::std::os::raw::c_uint = 256;
pub const TPM_RC_2: ::std::os::raw::c_uint = 512;
pub const TPM_RC_3: ::std::os::raw::c_uint = 768;
pub const TPM_RC_4: ::std::os::raw::c_uint = 1024;
pub const TPM_RC_5: ::std::os::raw::c_uint = 1280;
pub const TPM_RC_6: ::std::os::raw::c_uint = 1536;
pub const TPM_RC_7: ::std::os::raw::c_uint = 1792;
pub const TPM_RC_8: ::std::os::raw::c_uint = 2048;
pub const TPM_RC_9: ::std::os::raw::c_uint = 2304;
pub const TPM_RC_A: ::std::os::raw::c_uint = 2560;
pub const TPM_RC_B: ::std::os::raw::c_uint = 2816;
pub const TPM_RC_C: ::std::os::raw::c_uint = 3072;
pub const TPM_RC_D: ::std::os::raw::c_uint = 3328;
pub const TPM_RC_E: ::std::os::raw::c_uint = 3584;
pub const TPM_RC_F: ::std::os::raw::c_uint = 3840;
pub const TPM_RC_N_MASK: ::std::os::raw::c_uint = 3840;
pub const TPM_CLOCK_COARSE_SLOWER: ::std::os::raw::c_int = -3;
pub const TPM_CLOCK_MEDIUM_SLOWER: ::std::os::raw::c_int = -2;
pub const TPM_CLOCK_FINE_SLOWER: ::std::os::raw::c_int = -1;
pub const TPM_CLOCK_NO_CHANGE: ::std::os::raw::c_uint = 0;
pub const TPM_CLOCK_FINE_FASTER: ::std::os::raw::c_uint = 1;
pub const TPM_CLOCK_MEDIUM_FASTER: ::std::os::raw::c_uint = 2;
pub const TPM_CLOCK_COARSE_FASTER: ::std::os::raw::c_uint = 3;
pub const TPM_EO_EQ: ::std::os::raw::c_uint = 0;
pub const TPM_EO_NEQ: ::std::os::raw::c_uint = 1;
pub const TPM_EO_SIGNED_GT: ::std::os::raw::c_uint = 2;
pub const TPM_EO_UNSIGNED_GT: ::std::os::raw::c_uint = 3;
pub const TPM_EO_SIGNED_LT: ::std::os::raw::c_uint = 4;
pub const TPM_EO_UNSIGNED_LT: ::std::os::raw::c_uint = 5;
pub const TPM_EO_SIGNED_GE: ::std::os::raw::c_uint = 6;
pub const TPM_EO_UNSIGNED_GE: ::std::os::raw::c_uint = 7;
pub const TPM_EO_SIGNED_LE: ::std::os::raw::c_uint = 8;
pub const TPM_EO_UNSIGNED_LE: ::std::os::raw::c_uint = 9;
pub const TPM_EO_BITSET: ::std::os::raw::c_uint = 10;
pub const TPM_EO_BITCLEAR: ::std::os::raw::c_uint = 11;
pub const TPM_ST_RSP_COMMAND: ::std::os::raw::c_uint = 196;
pub const TPM_ST_NO_SESSIONS: ::std::os::raw::c_uint = 32769;
pub const TPM_ST_SESSIONS: ::std::os::raw::c_uint = 32770;
pub const TPM_ST_RESERVED1: ::std::os::raw::c_uint = 32771;
pub const TPM_ST_RESERVED2: ::std::os::raw::c_uint = 32772;
pub const TPM_ST_ATTEST_NV: ::std::os::raw::c_uint = 32788;
pub const TPM_ST_ATTEST_COMMAND_AUDIT: ::std::os::raw::c_uint = 32789;
pub const TPM_ST_ATTEST_SESSION_AUDIT: ::std::os::raw::c_uint = 32790;
pub const TPM_ST_ATTEST_CERTIFY: ::std::os::raw::c_uint = 32791;
pub const TPM_ST_ATTEST_QUOTE: ::std::os::raw::c_uint = 32792;
pub const TPM_ST_ATTEST_TIME: ::std::os::raw::c_uint = 32793;
pub const TPM_ST_ATTEST_CREATION: ::std::os::raw::c_uint = 32794;
pub const TPM_ST_RESERVED3: ::std::os::raw::c_uint = 32795;
pub const TPM_ST_CREATION: ::std::os::raw::c_uint = 32801;
pub const TPM_ST_VERIFIED: ::std::os::raw::c_uint = 32802;
pub const TPM_ST_AUTH_SECRET: ::std::os::raw::c_uint = 32803;
pub const TPM_ST_HASHCHECK: ::std::os::raw::c_uint = 32804;
pub const TPM_ST_AUTH_SIGNED: ::std::os::raw::c_uint = 32805;
pub const TPM_ST_FU_MANIFEST: ::std::os::raw::c_uint = 32809;
pub const TPM_SU_CLEAR: ::std::os::raw::c_uint = 0;
pub const TPM_SU_STATE: ::std::os::raw::c_uint = 1;
pub const TPM_SE_HMAC: ::std::os::raw::c_uint = 0;
pub const TPM_SE_POLICY: ::std::os::raw::c_uint = 1;
pub const TPM_SE_TRIAL: ::std::os::raw::c_uint = 3;
pub const TPM_CAP_FIRST: ::std::os::raw::c_uint = 0;
pub const TPM_CAP_ALGS: ::std::os::raw::c_uint = 0;
pub const TPM_CAP_HANDLES: ::std::os::raw::c_uint = 1;
pub const TPM_CAP_COMMANDS: ::std::os::raw::c_uint = 2;
pub const TPM_CAP_PP_COMMANDS: ::std::os::raw::c_uint = 3;
pub const TPM_CAP_AUDIT_COMMANDS: ::std::os::raw::c_uint = 4;
pub const TPM_CAP_PCRS: ::std::os::raw::c_uint = 5;
pub const TPM_CAP_TPM_PROPERTIES: ::std::os::raw::c_uint = 6;
pub const TPM_CAP_PCR_PROPERTIES: ::std::os::raw::c_uint = 7;
pub const TPM_CAP_ECC_CURVES: ::std::os::raw::c_uint = 8;
pub const TPM_CAP_LAST: ::std::os::raw::c_uint = 8;
pub const TPM_CAP_VENDOR_PROPERTY: ::std::os::raw::c_uint = 256;
pub const TPM_PT_NONE: ::std::os::raw::c_uint = 0;
pub const PT_GROUP: ::std::os::raw::c_uint = 256;
pub const PT_FIXED: ::std::os::raw::c_uint = 256;
pub const TPM_PT_FAMILY_INDICATOR: ::std::os::raw::c_uint = 256;
pub const TPM_PT_LEVEL: ::std::os::raw::c_uint = 257;
pub const TPM_PT_REVISION: ::std::os::raw::c_uint = 258;
pub const TPM_PT_DAY_OF_YEAR: ::std::os::raw::c_uint = 259;
pub const TPM_PT_YEAR: ::std::os::raw::c_uint = 260;
pub const TPM_PT_MANUFACTURER: ::std::os::raw::c_uint = 261;
pub const TPM_PT_VENDOR_STRING_1: ::std::os::raw::c_uint = 262;
pub const TPM_PT_VENDOR_STRING_2: ::std::os::raw::c_uint = 263;
pub const TPM_PT_VENDOR_STRING_3: ::std::os::raw::c_uint = 264;
pub const TPM_PT_VENDOR_STRING_4: ::std::os::raw::c_uint = 265;
pub const TPM_PT_VENDOR_TPM_TYPE: ::std::os::raw::c_uint = 266;
pub const TPM_PT_FIRMWARE_VERSION_1: ::std::os::raw::c_uint = 267;
pub const TPM_PT_FIRMWARE_VERSION_2: ::std::os::raw::c_uint = 268;
pub const TPM_PT_INPUT_BUFFER: ::std::os::raw::c_uint = 269;
pub const TPM_PT_HR_TRANSIENT_MIN: ::std::os::raw::c_uint = 270;
pub const TPM_PT_HR_PERSISTENT_MIN: ::std::os::raw::c_uint = 271;
pub const TPM_PT_HR_LOADED_MIN: ::std::os::raw::c_uint = 272;
pub const TPM_PT_ACTIVE_SESSIONS_MAX: ::std::os::raw::c_uint = 273;
pub const TPM_PT_PCR_COUNT: ::std::os::raw::c_uint = 274;
pub const TPM_PT_PCR_SELECT_MIN: ::std::os::raw::c_uint = 275;
pub const TPM_PT_CONTEXT_GAP_MAX: ::std::os::raw::c_uint = 276;
pub const TPM_PT_NV_COUNTERS_MAX: ::std::os::raw::c_uint = 278;
pub const TPM_PT_NV_INDEX_MAX: ::std::os::raw::c_uint = 279;
pub const TPM_PT_MEMORY: ::std::os::raw::c_uint = 280;
pub const TPM_PT_CLOCK_UPDATE: ::std::os::raw::c_uint = 281;
pub const TPM_PT_CONTEXT_HASH: ::std::os::raw::c_uint = 282;
pub const TPM_PT_CONTEXT_SYM: ::std::os::raw::c_uint = 283;
pub const TPM_PT_CONTEXT_SYM_SIZE: ::std::os::raw::c_uint = 284;
pub const TPM_PT_ORDERLY_COUNT: ::std::os::raw::c_uint = 285;
pub const TPM_PT_MAX_COMMAND_SIZE: ::std::os::raw::c_uint = 286;
pub const TPM_PT_MAX_RESPONSE_SIZE: ::std::os::raw::c_uint = 287;
pub const TPM_PT_MAX_DIGEST: ::std::os::raw::c_uint = 288;
pub const TPM_PT_MAX_OBJECT_CONTEXT: ::std::os::raw::c_uint = 289;
pub const TPM_PT_MAX_SESSION_CONTEXT: ::std::os::raw::c_uint = 290;
pub const TPM_PT_PS_FAMILY_INDICATOR: ::std::os::raw::c_uint = 291;
pub const TPM_PT_PS_LEVEL: ::std::os::raw::c_uint = 292;
pub const TPM_PT_PS_REVISION: ::std::os::raw::c_uint = 293;
pub const TPM_PT_PS_DAY_OF_YEAR: ::std::os::raw::c_uint = 294;
pub const TPM_PT_PS_YEAR: ::std::os::raw::c_uint = 295;
pub const TPM_PT_SPLIT_MAX: ::std::os::raw::c_uint = 296;
pub const TPM_PT_TOTAL_COMMANDS: ::std::os::raw::c_uint = 297;
pub const TPM_PT_LIBRARY_COMMANDS: ::std::os::raw::c_uint = 298;
pub const TPM_PT_VENDOR_COMMANDS: ::std::os::raw::c_uint = 299;
pub const TPM_PT_NV_BUFFER_MAX: ::std::os::raw::c_uint = 300;
pub const TPM_PT_MODES: ::std::os::raw::c_uint = 301;
pub const PT_VAR: ::std::os::raw::c_uint = 512;
pub const TPM_PT_PERMANENT: ::std::os::raw::c_uint = 512;
pub const TPM_PT_STARTUP_CLEAR: ::std::os::raw::c_uint = 513;
pub const TPM_PT_HR_NV_INDEX: ::std::os::raw::c_uint = 514;
pub const TPM_PT_HR_LOADED: ::std::os::raw::c_uint = 515;
pub const TPM_PT_HR_LOADED_AVAIL: ::std::os::raw::c_uint = 516;
pub const TPM_PT_HR_ACTIVE: ::std::os::raw::c_uint = 517;
pub const TPM_PT_HR_ACTIVE_AVAIL: ::std::os::raw::c_uint = 518;
pub const TPM_PT_HR_TRANSIENT_AVAIL: ::std::os::raw::c_uint = 519;
pub const TPM_PT_HR_PERSISTENT: ::std::os::raw::c_uint = 520;
pub const TPM_PT_HR_PERSISTENT_AVAIL: ::std::os::raw::c_uint = 521;
pub const TPM_PT_NV_COUNTERS: ::std::os::raw::c_uint = 522;
pub const TPM_PT_NV_COUNTERS_AVAIL: ::std::os::raw::c_uint = 523;
pub const TPM_PT_ALGORITHM_SET: ::std::os::raw::c_uint = 524;
pub const TPM_PT_LOADED_CURVES: ::std::os::raw::c_uint = 525;
pub const TPM_PT_LOCKOUT_COUNTER: ::std::os::raw::c_uint = 526;
pub const TPM_PT_MAX_AUTH_FAIL: ::std::os::raw::c_uint = 527;
pub const TPM_PT_LOCKOUT_INTERVAL: ::std::os::raw::c_uint = 528;
pub const TPM_PT_LOCKOUT_RECOVERY: ::std::os::raw::c_uint = 529;
pub const TPM_PT_NV_WRITE_RECOVERY: ::std::os::raw::c_uint = 530;
pub const TPM_PT_AUDIT_COUNTER_0: ::std::os::raw::c_uint = 531;
pub const TPM_PT_AUDIT_COUNTER_1: ::std::os::raw::c_uint = 532;
pub const TPM_PT_PCR_FIRST: ::std::os::raw::c_uint = 0;
pub const TPM_PT_PCR_SAVE: ::std::os::raw::c_uint = 0;
pub const TPM_PT_PCR_EXTEND_L0: ::std::os::raw::c_uint = 1;
pub const TPM_PT_PCR_RESET_L0: ::std::os::raw::c_uint = 2;
pub const TPM_PT_PCR_EXTEND_L1: ::std::os::raw::c_uint = 3;
pub const TPM_PT_PCR_RESET_L1: ::std::os::raw::c_uint = 4;
pub const TPM_PT_PCR_EXTEND_L2: ::std::os::raw::c_uint = 5;
pub const TPM_PT_PCR_RESET_L2: ::std::os::raw::c_uint = 6;
pub const TPM_PT_PCR_EXTEND_L3: ::std::os::raw::c_uint = 7;
pub const TPM_PT_PCR_RESET_L3: ::std::os::raw::c_uint = 8;
pub const TPM_PT_PCR_EXTEND_L4: ::std::os::raw::c_uint = 9;
pub const TPM_PT_PCR_RESET_L4: ::std::os::raw::c_uint = 10;
pub const TPM_PT_PCR_NO_INCREMENT: ::std::os::raw::c_uint = 17;
pub const TPM_PT_PCR_DRTM_RESET: ::std::os::raw::c_uint = 18;
pub const TPM_PT_PCR_POLICY: ::std::os::raw::c_uint = 19;
pub const TPM_PT_PCR_AUTH: ::std::os::raw::c_uint = 20;
pub const TPM_PT_PCR_RESERVED2: ::std::os::raw::c_uint = 21;
pub const TPM_PT_PCR_RESERVED3: ::std::os::raw::c_uint = 22;
pub const TPM_PT_PCR_RESERVED5: ::std::os::raw::c_uint = 529;
pub const TPM_PT_PCR_RESERVED6: ::std::os::raw::c_uint = 530;
pub const TPM_PT_PCR_RESERVED7: ::std::os::raw::c_uint = 531;
pub const TPM_PT_PCR_LAST: ::std::os::raw::c_uint = 20;
pub const TPM_PS_MAIN: ::std::os::raw::c_uint = 0;
pub const TPM_PS_PC: ::std::os::raw::c_uint = 1;
pub const TPM_PS_PDA: ::std::os::raw::c_uint = 2;
pub const TPM_PS_CELL_PHONE: ::std::os::raw::c_uint = 3;
pub const TPM_PS_SERVER: ::std::os::raw::c_uint = 4;
pub const TPM_PS_PERIPHERAL: ::std::os::raw::c_uint = 5;
pub const TPM_PS_TSS: ::std::os::raw::c_uint = 6;
pub const TPM_PS_STORAGE: ::std::os::raw::c_uint = 7;
pub const TPM_PS_AUTHENTICATION: ::std::os::raw::c_uint = 8;
pub const TPM_PS_EMBEDDED: ::std::os::raw::c_uint = 9;
pub const TPM_PS_HARDCOPY: ::std::os::raw::c_uint = 10;
pub const TPM_PS_INFRASTRUCTURE: ::std::os::raw::c_uint = 11;
pub const TPM_PS_VIRTUALIZATION: ::std::os::raw::c_uint = 12;
pub const TPM_PS_TNC: ::std::os::raw::c_uint = 13;
pub const TPM_PS_MULTI_TENANT: ::std::os::raw::c_uint = 14;
pub const TPM_PS_TC: ::std::os::raw::c_uint = 15;
pub const TPM_HT_PCR: ::std::os::raw::c_uint = 0;
pub const TPM_HT_NV_INDEX: ::std::os::raw::c_uint = 1;
pub const TPM_HT_HMAC_SESSION: ::std::os::raw::c_uint = 2;
pub const TPM_HT_LOADED_SESSION: ::std::os::raw::c_uint = 2;
pub const TPM_HT_POLICY_SESSION: ::std::os::raw::c_uint = 3;
pub const TPM_HT_SAVED_SESSION: ::std::os::raw::c_uint = 3;
pub const TPM_HT_PERMANENT: ::std::os::raw::c_uint = 64;
pub const TPM_HT_TRANSIENT: ::std::os::raw::c_uint = 128;
pub const TPM_HT_PERSISTENT: ::std::os::raw::c_uint = 129;
pub const TPM_RH_FIRST: ::std::os::raw::c_uint = 1073741824;
pub const TPM_RH_SRK: ::std::os::raw::c_uint = 1073741824;
pub const TPM_RH_OWNER: ::std::os::raw::c_uint = 1073741825;
pub const TPM_RH_REVOKE: ::std::os::raw::c_uint = 1073741826;
pub const TPM_RH_TRANSPORT: ::std::os::raw::c_uint = 1073741827;
pub const TPM_RH_OPERATOR: ::std::os::raw::c_uint = 1073741828;
pub const TPM_RH_ADMIN: ::std::os::raw::c_uint = 1073741829;
pub const TPM_RH_EK: ::std::os::raw::c_uint = 1073741830;
pub const TPM_RH_NULL: ::std::os::raw::c_uint = 1073741831;
pub const TPM_RH_UNASSIGNED: ::std::os::raw::c_uint = 1073741832;
pub const TPM_RS_PW: ::std::os::raw::c_uint = 1073741833;
pub const TPM_RH_LOCKOUT: ::std::os::raw::c_uint = 1073741834;
pub const TPM_RH_ENDORSEMENT: ::std::os::raw::c_uint = 1073741835;
pub const TPM_RH_PLATFORM: ::std::os::raw::c_uint = 1073741836;
pub const TPM_RH_PLATFORM_NV: ::std::os::raw::c_uint = 1073741837;
pub const TPM_RH_AUTH_00: ::std::os::raw::c_uint = 1073741840;
pub const TPM_RH_AUTH_FF: ::std::os::raw::c_uint = 1073742095;
pub const TPM_RH_LAST: ::std::os::raw::c_uint = 1073742095;
pub const HR_HANDLE_MASK: ::std::os::raw::c_uint = 16777215;
pub const HR_RANGE_MASK: ::std::os::raw::c_uint = 4278190080;
pub const HR_SHIFT: ::std::os::raw::c_uint = 24;
pub const HR_PCR: ::std::os::raw::c_uint = 0;
pub const HR_HMAC_SESSION: ::std::os::raw::c_uint = 33554432;
pub const HR_POLICY_SESSION: ::std::os::raw::c_uint = 50331648;
pub const HR_TRANSIENT: ::std::os::raw::c_uint = 2147483648;
pub const HR_PERSISTENT: ::std::os::raw::c_uint = 2164260864;
pub const HR_NV_INDEX: ::std::os::raw::c_uint = 16777216;
pub const HR_PERMANENT: ::std::os::raw::c_uint = 1073741824;
pub const PCR_FIRST: ::std::os::raw::c_uint = 0;
pub const PCR_LAST: ::std::os::raw::c_uint = 23;
pub const HMAC_SESSION_FIRST: ::std::os::raw::c_uint = 33554432;
pub const LOADED_SESSION_FIRST: ::std::os::raw::c_uint = 33554432;
pub const POLICY_SESSION_FIRST: ::std::os::raw::c_uint = 50331648;
pub const TRANSIENT_FIRST: ::std::os::raw::c_uint = 2147483648;
pub const ACTIVE_SESSION_FIRST: ::std::os::raw::c_uint = 50331648;
pub const TRANSIENT_LAST: ::std::os::raw::c_uint = 2147483650;
pub const PERSISTENT_FIRST: ::std::os::raw::c_uint = 2164260864;
pub const PERSISTENT_LAST: ::std::os::raw::c_uint = 2181038079;
pub const PLATFORM_PERSISTENT: ::std::os::raw::c_uint = 2172649472;
pub const NV_INDEX_FIRST: ::std::os::raw::c_uint = 16777216;
pub const NV_INDEX_LAST: ::std::os::raw::c_uint = 33554431;
pub const PERMANENT_FIRST: ::std::os::raw::c_uint = 1073741824;
pub const PERMANENT_LAST: ::std::os::raw::c_uint = 1073742095;
pub const TPMA_ALGORITHM_ASYMMETRIC: ::std::os::raw::c_uint = 1;
pub const TPMA_ALGORITHM_SYMMETRIC: ::std::os::raw::c_uint = 2;
pub const TPMA_ALGORITHM_HASH: ::std::os::raw::c_uint = 4;
pub const TPMA_ALGORITHM_OBJECT: ::std::os::raw::c_uint = 8;
pub const TPMA_ALGORITHM_RESERVED1: ::std::os::raw::c_uint = 240;
pub const TPMA_ALGORITHM_SIGNING: ::std::os::raw::c_uint = 256;
pub const TPMA_ALGORITHM_ENCRYPTING: ::std::os::raw::c_uint = 512;
pub const TPMA_ALGORITHM_METHOD: ::std::os::raw::c_uint = 1024;
pub const TPMA_ALGORITHM_RESERVED2: ::std::os::raw::c_uint = 4294965248;
pub const TPMA_OBJECT_RESERVED1: ::std::os::raw::c_uint = 1;
pub const TPMA_OBJECT_FIXEDTPM: ::std::os::raw::c_uint = 2;
pub const TPMA_OBJECT_STCLEAR: ::std::os::raw::c_uint = 4;
pub const TPMA_OBJECT_RESERVED2: ::std::os::raw::c_uint = 8;
pub const TPMA_OBJECT_FIXEDPARENT: ::std::os::raw::c_uint = 16;
pub const TPMA_OBJECT_SENSITIVEDATAORIGIN: ::std::os::raw::c_uint = 32;
pub const TPMA_OBJECT_USERWITHAUTH: ::std::os::raw::c_uint = 64;
pub const TPMA_OBJECT_ADMINWITHPOLICY: ::std::os::raw::c_uint = 128;
pub const TPMA_OBJECT_RESERVED3: ::std::os::raw::c_uint = 768;
pub const TPMA_OBJECT_NODA: ::std::os::raw::c_uint = 1024;
pub const TPMA_OBJECT_ENCRYPTEDDUPLICATION: ::std::os::raw::c_uint = 2048;
pub const TPMA_OBJECT_RESERVED4: ::std::os::raw::c_uint = 61440;
pub const TPMA_OBJECT_RESTRICTED: ::std::os::raw::c_uint = 65536;
pub const TPMA_OBJECT_DECRYPT: ::std::os::raw::c_uint = 131072;
pub const TPMA_OBJECT_SIGN: ::std::os::raw::c_uint = 262144;
pub const TPMA_OBJECT_RESERVED5: ::std::os::raw::c_uint = 4294443008;
pub const TPMA_SESSION_CONTINUESESSION: ::std::os::raw::c_uint = 1;
pub const TPMA_SESSION_AUDITEXCLUSIVE: ::std::os::raw::c_uint = 2;
pub const TPMA_SESSION_AUDITRESET: ::std::os::raw::c_uint = 4;
pub const TPMA_SESSION_RESERVED1: ::std::os::raw::c_uint = 24;
pub const TPMA_SESSION_DECRYPT: ::std::os::raw::c_uint = 32;
pub const TPMA_SESSION_ENCRYPT: ::std::os::raw::c_uint = 64;
pub const TPMA_SESSION_AUDIT: ::std::os::raw::c_uint = 128;
pub const TPMA_LOCALITY_TPM_LOC_ZERO: ::std::os::raw::c_uint = 1;
pub const TPMA_LOCALITY_TPM_LOC_ONE: ::std::os::raw::c_uint = 2;
pub const TPMA_LOCALITY_TPM_LOC_TWO: ::std::os::raw::c_uint = 4;
pub const TPMA_LOCALITY_TPM_LOC_THREE: ::std::os::raw::c_uint = 8;
pub const TPMA_LOCALITY_TPM_LOC_FOUR: ::std::os::raw::c_uint = 16;
pub const TPMA_LOCALITY_EXTENDED: ::std::os::raw::c_uint = 224;
pub const TPMA_PERMANENT_OWNERAUTHSET: ::std::os::raw::c_uint = 1;
pub const TPMA_PERMANENT_ENDORSEMENTAUTHSET: ::std::os::raw::c_uint = 2;
pub const TPMA_PERMANENT_LOCKOUTAUTHSET: ::std::os::raw::c_uint = 4;
pub const TPMA_PERMANENT_RESERVED1: ::std::os::raw::c_uint = 248;
pub const TPMA_PERMANENT_DISABLECLEAR: ::std::os::raw::c_uint = 256;
pub const TPMA_PERMANENT_INLOCKOUT: ::std::os::raw::c_uint = 512;
pub const TPMA_PERMANENT_TPMGENERATEDEPS: ::std::os::raw::c_uint = 1024;
pub const TPMA_PERMANENT_RESERVED2: ::std::os::raw::c_uint = 4294965248;
pub const TPMA_STARTUP_CLEAR_PHENABLE: ::std::os::raw::c_uint = 1;
pub const TPMA_STARTUP_CLEAR_SHENABLE: ::std::os::raw::c_uint = 2;
pub const TPMA_STARTUP_CLEAR_EHENABLE: ::std::os::raw::c_uint = 4;
pub const TPMA_STARTUP_CLEAR_PHENABLENV: ::std::os::raw::c_uint = 8;
pub const TPMA_STARTUP_CLEAR_RESERVED1: ::std::os::raw::c_uint = 2147483632;
pub const TPMA_STARTUP_CLEAR_ORDERLY: ::std::os::raw::c_uint = 2147483648;
pub const TPMA_MEMORY_SHAREDRAM: ::std::os::raw::c_uint = 1;
pub const TPMA_MEMORY_SHAREDNV: ::std::os::raw::c_uint = 2;
pub const TPMA_MEMORY_OBJECTCOPIEDTORAM: ::std::os::raw::c_uint = 4;
pub const TPMA_MEMORY_RESERVED1: ::std::os::raw::c_uint = 4294967288;
pub const TPMA_CC_COMMANDINDEX: ::std::os::raw::c_uint = 65535;
pub const TPMA_CC_RESERVED1: ::std::os::raw::c_uint = 4128768;
pub const TPMA_CC_NV: ::std::os::raw::c_uint = 4194304;
pub const TPMA_CC_EXTENSIVE: ::std::os::raw::c_uint = 8388608;
pub const TPMA_CC_FLUSHED: ::std::os::raw::c_uint = 16777216;
pub const TPMA_CC_CHANDLES: ::std::os::raw::c_uint = 234881024;
pub const TPMA_CC_RHANDLE: ::std::os::raw::c_uint = 268435456;
pub const TPMA_CC_V: ::std::os::raw::c_uint = 536870912;
pub const TPMA_CC_RES: ::std::os::raw::c_uint = 3221225472;
pub const TPMA_MODES_FIPS_140_2: ::std::os::raw::c_uint = 1;
pub const TPMA_MODES_RESERVED1: ::std::os::raw::c_uint = 4294967294;
pub const TPM_NV_INDEX_INDEX: ::std::os::raw::c_uint = 16777215;
pub const TPM_NV_INDEX_RH_NV: ::std::os::raw::c_uint = 4278190080;
pub const TPM_NT_ORDINARY: ::std::os::raw::c_uint = 0;
pub const TPM_NT_COUNTER: ::std::os::raw::c_uint = 1;
pub const TPM_NT_BITS: ::std::os::raw::c_uint = 2;
pub const TPM_NT_EXTEND: ::std::os::raw::c_uint = 4;
pub const TPM_NT_PIN_FAIL: ::std::os::raw::c_uint = 8;
pub const TPM_NT_PIN_PASS: ::std::os::raw::c_uint = 9;
pub const TPMA_NV_TPMA_NV_PPWRITE: ::std::os::raw::c_uint = 1;
pub const TPMA_NV_TPMA_NV_OWNERWRITE: ::std::os::raw::c_uint = 2;
pub const TPMA_NV_TPMA_NV_AUTHWRITE: ::std::os::raw::c_uint = 4;
pub const TPMA_NV_TPMA_NV_POLICYWRITE: ::std::os::raw::c_uint = 8;
pub const TPMA_NV_TPM_NT: ::std::os::raw::c_uint = 240;
pub const TPMA_NV_RESERVED1: ::std::os::raw::c_uint = 768;
pub const TPMA_NV_TPMA_NV_POLICY_DELETE: ::std::os::raw::c_uint = 1024;
pub const TPMA_NV_TPMA_NV_WRITELOCKED: ::std::os::raw::c_uint = 2048;
pub const TPMA_NV_TPMA_NV_WRITEALL: ::std::os::raw::c_uint = 4096;
pub const TPMA_NV_TPMA_NV_WRITEDEFINE: ::std::os::raw::c_uint = 8192;
pub const TPMA_NV_TPMA_NV_WRITE_STCLEAR: ::std::os::raw::c_uint = 16384;
pub const TPMA_NV_TPMA_NV_GLOBALLOCK: ::std::os::raw::c_uint = 32768;
pub const TPMA_NV_TPMA_NV_PPREAD: ::std::os::raw::c_uint = 65536;
pub const TPMA_NV_TPMA_NV_OWNERREAD: ::std::os::raw::c_uint = 131072;
pub const TPMA_NV_TPMA_NV_AUTHREAD: ::std::os::raw::c_uint = 262144;
pub const TPMA_NV_TPMA_NV_POLICYREAD: ::std::os::raw::c_uint = 524288;
pub const TPMA_NV_RESERVED2: ::std::os::raw::c_uint = 32505856;
pub const TPMA_NV_TPMA_NV_NO_DA: ::std::os::raw::c_uint = 33554432;
pub const TPMA_NV_TPMA_NV_ORDERLY: ::std::os::raw::c_uint = 67108864;
pub const TPMA_NV_TPMA_NV_CLEAR_STCLEAR: ::std::os::raw::c_uint = 134217728;
pub const TPMA_NV_TPMA_NV_READLOCKED: ::std::os::raw::c_uint = 268435456;
pub const TPMA_NV_TPMA_NV_WRITTEN: ::std::os::raw::c_uint = 536870912;
pub const TPMA_NV_TPMA_NV_PLATFORMCREATE: ::std::os::raw::c_uint = 1073741824;
pub const TPMA_NV_TPMA_NV_READ_STCLEAR: ::std::os::raw::c_uint = 2147483648;
pub const _SYS_POLL_H: ::std::os::raw::c_uint = 1;
pub const POLLIN: ::std::os::raw::c_uint = 1;
pub const POLLPRI: ::std::os::raw::c_uint = 2;
pub const POLLOUT: ::std::os::raw::c_uint = 4;
pub const POLLRDNORM: ::std::os::raw::c_uint = 64;
pub const POLLRDBAND: ::std::os::raw::c_uint = 128;
pub const POLLWRNORM: ::std::os::raw::c_uint = 256;
pub const POLLWRBAND: ::std::os::raw::c_uint = 512;
pub const POLLERR: ::std::os::raw::c_uint = 8;
pub const POLLHUP: ::std::os::raw::c_uint = 16;
pub const POLLNVAL: ::std::os::raw::c_uint = 32;
pub const TSS2_TCTI_TIMEOUT_BLOCK: ::std::os::raw::c_int = -1;
pub const TSS2_TCTI_TIMEOUT_NONE: ::std::os::raw::c_uint = 0;
pub const TSSWG_INTEROP: ::std::os::raw::c_uint = 1;
pub const MAX_NON_VENDOR_SPECIFIC: ::std::os::raw::c_uint = 536870912;
pub const TSS_SAPI_FIRST_FAMILY: ::std::os::raw::c_uint = 1;
pub const TSS_SAPI_FIRST_LEVEL: ::std::os::raw::c_uint = 1;
pub const TSS_SAPI_FIRST_VERSION: ::std::os::raw::c_uint = 1;
pub const DEFAULT_SIMULATOR_TPM_PORT: ::std::os::raw::c_uint = 2321;
pub const DEFAULT_HOSTNAME: &'static [u8; 10usize] = b"127.0.0.1\x00";
pub const MS_SIM_POWER_ON: ::std::os::raw::c_uint = 1;
pub const MS_SIM_POWER_OFF: ::std::os::raw::c_uint = 2;
pub const MS_SIM_TPM_SEND_COMMAND: ::std::os::raw::c_uint = 8;
pub const MS_SIM_CANCEL_ON: ::std::os::raw::c_uint = 9;
pub const MS_SIM_CANCEL_OFF: ::std::os::raw::c_uint = 10;
pub const MS_SIM_NV_ON: ::std::os::raw::c_uint = 11;
pub const TPM_SESSION_END: ::std::os::raw::c_uint = 20;
pub type wchar_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t { P_ALL = 0, P_PID = 1, P_PGID = 2, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( div_t ) ));
    assert_eq! (::std::mem::align_of::<div_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( div_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const div_t ) ) . rem as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( div_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for div_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq! (::std::mem::align_of::<ldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . quot as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for ldiv_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq! (::std::mem::align_of::<lldiv_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . quot as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( quot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lldiv_t ) ) . rem as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lldiv_t ) , "::" ,
                stringify ! ( rem ) ));
}
impl Clone for lldiv_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq! (::std::mem::align_of::<__sigset_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __sigset_t {
    fn clone(&self) -> Self { *self }
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_attr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_attr_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_attr_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_attr_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_attr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (::std::mem::align_of::<__pthread_internal_list>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __prev as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __prev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __pthread_internal_list ) ) . __next as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __pthread_internal_list
                ) , "::" , stringify ! ( __next ) ));
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
impl Default for __pthread_internal_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_mutex_t {
    pub __data: __BindgenUnionField<pthread_mutex_t___pthread_mutex_s>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 40usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s )
               ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __count as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __owner as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __nusers as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __nusers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __kind as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __spins as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __spins ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __elision as * const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __elision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t___pthread_mutex_s ) ) .
                __list as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! (
                __list ) ));
}
impl Clone for pthread_mutex_t___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_mutex_t___pthread_mutex_s {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutex_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutex_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutex_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutex_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_mutexattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>() , 4usize , concat
               ! ( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_mutexattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_mutexattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_mutexattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_cond_t {
    pub __data: __BindgenUnionField<pthread_cond_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 48usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) . __lock
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __futex as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __total_seq as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __total_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __wakeup_seq as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __wakeup_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __woken_seq as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __woken_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __mutex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __nwaiters as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nwaiters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t__bindgen_ty_1 ) ) .
                __broadcast_seq as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! (
                __broadcast_seq ) ));
}
impl Clone for pthread_cond_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_cond_t__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_cond_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __data as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_cond_t ) ) . __align as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_cond_t ) , "::"
                , stringify ! ( __align ) ));
}
impl Clone for pthread_cond_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_condattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>() , 4usize , concat !
               ( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_condattr_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_condattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_condattr_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlock_t {
    pub __data: __BindgenUnionField<pthread_rwlock_t__bindgen_ty_1>,
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 56usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __lock as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __readers_wakeup as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __readers_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer_wakeup as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer_wakeup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_readers_queued as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_readers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __nr_writers_queued as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __nr_writers_queued ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __writer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __writer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __shared as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __rwelision as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __rwelision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad1 as * const _ as usize } , 33usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __pad2 as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t__bindgen_ty_1 ) ) .
                __flags as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! (
                __flags ) ));
}
impl Clone for pthread_rwlock_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>() , 56usize , concat !
               ( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlock_t>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __data as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlock_t ) ) . __align as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlock_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlock_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_rwlockattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 8usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_rwlockattr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_rwlockattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_rwlockattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_barrier_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 32usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_long>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (::std::mem::align_of::<pthread_barrier_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __size as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrier_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrier_t ) ,
                "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrier_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pthread_barrierattr_t {
    pub __size: __BindgenUnionField<[::std::os::raw::c_char; 4usize]>,
    pub __align: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( pthread_barrierattr_t )
               ));
    assert_eq! (::std::mem::align_of::<pthread_barrierattr_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_barrierattr_t ) ) . __align as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_barrierattr_t )
                , "::" , stringify ! ( __align ) ));
}
impl Clone for pthread_barrierattr_t {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize , concat ! (
               "Size of: " , stringify ! ( random_data ) ));
    assert_eq! (::std::mem::align_of::<random_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( random_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . fptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( fptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rptr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . state as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_type as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_deg as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_deg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . rand_sep as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( rand_sep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const random_data ) ) . end_ptr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( random_data ) , "::" ,
                stringify ! ( end_ptr ) ));
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
impl Default for random_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize , concat ! (
               "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq! (::std::mem::align_of::<drand48_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __old_x as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __old_x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __c as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __init as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const drand48_data ) ) . __a as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( drand48_data ) , "::" ,
                stringify ! ( __a ) ));
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize , concat !
               ( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq! (::std::mem::align_of::<__locale_struct>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __locales as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __locales ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_b as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_tolower as
                * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __ctype_toupper as
                * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __locale_struct ) ) . __names as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __locale_struct ) ,
                "::" , stringify ! ( __names ) ));
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
impl Default for __locale_struct {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
pub type UINT8 = u8;
pub type BYTE = u8;
pub type INT8 = i8;
pub type BOOL = ::std::os::raw::c_int;
pub type UINT16 = u16;
pub type INT16 = i16;
pub type UINT32 = u32;
pub type INT32 = i32;
pub type UINT64 = u64;
pub type INT64 = i64;
pub type TSS2_RC = UINT32;
/**
 * ABI runetime negotiation structure.
 */
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TSS2_ABI_VERSION {
    pub tssCreator: UINT32,
    pub tssFamily: UINT32,
    pub tssLevel: UINT32,
    pub tssVersion: UINT32,
}
#[test]
fn bindgen_test_layout_TSS2_ABI_VERSION() {
    assert_eq!(::std::mem::size_of::<TSS2_ABI_VERSION>() , 16usize , concat !
               ( "Size of: " , stringify ! ( TSS2_ABI_VERSION ) ));
    assert_eq! (::std::mem::align_of::<TSS2_ABI_VERSION>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TSS2_ABI_VERSION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_ABI_VERSION ) ) . tssCreator as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_ABI_VERSION ) ,
                "::" , stringify ! ( tssCreator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_ABI_VERSION ) ) . tssFamily as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_ABI_VERSION ) ,
                "::" , stringify ! ( tssFamily ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_ABI_VERSION ) ) . tssLevel as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_ABI_VERSION ) ,
                "::" , stringify ! ( tssLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_ABI_VERSION ) ) . tssVersion as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_ABI_VERSION ) ,
                "::" , stringify ! ( tssVersion ) ));
}
impl Clone for TSS2_ABI_VERSION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B {
    pub size: UINT16,
    pub buffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_TPM2B() {
    assert_eq!(::std::mem::size_of::<TPM2B>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPM2B ) ));
    assert_eq! (::std::mem::align_of::<TPM2B>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B ) ) . size as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B ) ) . buffer as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Clone for TPM2B {
    fn clone(&self) -> Self { *self }
}
pub type TPM_ALG_ID = UINT16;
pub type TPM_ECC_CURVE = UINT16;
pub type TPM_CC = UINT32;
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_MAX_HASH_BLOCK {
    pub t: __BindgenUnionField<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 65usize],
}
#[repr(C)]
pub struct TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_HASH_BLOCK__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>() ,
               130usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_MAX_HASH_BLOCK__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_HASH_BLOCK__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_MAX_HASH_BLOCK__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_HASH_BLOCK() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_HASH_BLOCK>() , 130usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_MAX_HASH_BLOCK )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_HASH_BLOCK>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_MAX_HASH_BLOCK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_HASH_BLOCK ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_HASH_BLOCK )
                , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_HASH_BLOCK ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_HASH_BLOCK )
                , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_MAX_HASH_BLOCK {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_MAX_HASH_BLOCK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPM2B_HASH_BLOCK = TPM2B_MAX_HASH_BLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_SEED {
    pub t: __BindgenUnionField<TPM2B_SEED__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 17usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_SEED__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SEED__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_SEED__bindgen_ty_1>() , 34usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM2B_SEED__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SEED__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_SEED__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SEED__bindgen_ty_1 ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SEED__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SEED__bindgen_ty_1 ) ) . buffer as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SEED__bindgen_ty_1 ) , "::" , stringify ! ( buffer ) ));
}
impl Clone for TPM2B_SEED__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TPM2B_SEED() {
    assert_eq!(::std::mem::size_of::<TPM2B_SEED>() , 34usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_SEED ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SEED>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_SEED ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SEED ) ) . t as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SEED ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SEED ) ) . b as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SEED ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_SEED {
    fn clone(&self) -> Self { *self }
}
pub type TPM_ALGORITHM_ID = UINT32;
pub type TPM_MODIFIER_INDICATOR = UINT32;
pub type TPM_AUTHORIZATION_SIZE = UINT32;
pub type TPM_PARAMETER_SIZE = UINT32;
pub type TPM_KEY_SIZE = UINT16;
pub type TPM_KEY_BITS = UINT16;
pub type TPM_SPEC = UINT32;
pub type TPM_GENERATED = UINT32;
pub type TPM_RC = UINT32;
pub type TPM_CLOCK_ADJUST = INT8;
pub type TPM_EO = UINT16;
pub type TPM_ST = UINT16;
pub type TPM_SU = UINT16;
pub type TPM_SE = UINT8;
pub type TPM_CAP = UINT32;
pub type TPM_PT = UINT32;
pub type TPM_PT_PCR = UINT32;
pub type TPM_PS = UINT32;
pub type TPM_HANDLE = UINT32;
pub type TPM_HT = UINT8;
pub type TPM_RH = TPM_HANDLE;
pub type TPM_HC = TPM_HANDLE;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_ALGORITHM {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_ALGORITHM__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_ALGORITHM__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_ALGORITHM__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_ALGORITHM__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( TPMA_ALGORITHM__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_ALGORITHM__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_ALGORITHM__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_ALGORITHM__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_ALGORITHM__bindgen_ty_1 {
    #[inline]
    pub fn asymmetric(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_asymmetric(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn symmetric(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_symmetric(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn hash(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_hash(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn object(&self) -> ::std::os::raw::c_uint {
        let mask = 8usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_object(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 240usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 240usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn signing(&self) -> ::std::os::raw::c_uint {
        let mask = 256usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_signing(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn encrypting(&self) -> ::std::os::raw::c_uint {
        let mask = 512usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_encrypting(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn method(&self) -> ::std::os::raw::c_uint {
        let mask = 1024usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_method(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> ::std::os::raw::c_uint {
        let mask = 4294965248usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294965248usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(asymmetric: ::std::os::raw::c_uint,
                          symmetric: ::std::os::raw::c_uint,
                          hash: ::std::os::raw::c_uint,
                          object: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          signing: ::std::os::raw::c_uint,
                          encrypting: ::std::os::raw::c_uint,
                          method: ::std::os::raw::c_uint,
                          reserved2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((asymmetric as u32 as
                                                           u32) << 0usize) &
                                                         (1usize as u32))
                                            } |
                                                ((symmetric as u32 as u32) <<
                                                     1usize) &
                                                    (2usize as u32))
                                       } |
                                           ((hash as u32 as u32) << 2usize) &
                                               (4usize as u32))
                                  } |
                                      ((object as u32 as u32) << 3usize) &
                                          (8usize as u32))
                             } |
                                 ((reserved1 as u32 as u32) << 4usize) &
                                     (240usize as u32))
                        } |
                            ((signing as u32 as u32) << 8usize) &
                                (256usize as u32))
                   } |
                       ((encrypting as u32 as u32) << 9usize) &
                           (512usize as u32))
              } | ((method as u32 as u32) << 10usize) & (1024usize as u32))
         } |
             ((reserved2 as u32 as u32) << 11usize) &
                 (4294965248usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_ALGORITHM() {
    assert_eq!(::std::mem::size_of::<TPMA_ALGORITHM>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_ALGORITHM ) ));
    assert_eq! (::std::mem::align_of::<TPMA_ALGORITHM>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_ALGORITHM ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_ALGORITHM ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_ALGORITHM ) , "::"
                , stringify ! ( val ) ));
}
impl Clone for TPMA_ALGORITHM {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_OBJECT {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_OBJECT__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_OBJECT__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_OBJECT__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_OBJECT__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMA_OBJECT__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_OBJECT__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMA_OBJECT__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_OBJECT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_OBJECT__bindgen_ty_1 {
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn fixedTPM(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fixedTPM(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn stClear(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_stClear(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> ::std::os::raw::c_uint {
        let mask = 8usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn fixedParent(&self) -> ::std::os::raw::c_uint {
        let mask = 16usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_fixedParent(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn sensitiveDataOrigin(&self) -> ::std::os::raw::c_uint {
        let mask = 32usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sensitiveDataOrigin(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn userWithAuth(&self) -> ::std::os::raw::c_uint {
        let mask = 64usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_userWithAuth(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn adminWithPolicy(&self) -> ::std::os::raw::c_uint {
        let mask = 128usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_adminWithPolicy(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved3(&self) -> ::std::os::raw::c_uint {
        let mask = 768usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved3(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 768usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn noDA(&self) -> ::std::os::raw::c_uint {
        let mask = 1024usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_noDA(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn encryptedDuplication(&self) -> ::std::os::raw::c_uint {
        let mask = 2048usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_encryptedDuplication(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved4(&self) -> ::std::os::raw::c_uint {
        let mask = 61440usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved4(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 61440usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn restricted(&self) -> ::std::os::raw::c_uint {
        let mask = 65536usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_restricted(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn decrypt(&self) -> ::std::os::raw::c_uint {
        let mask = 131072usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_decrypt(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 131072usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn sign(&self) -> ::std::os::raw::c_uint {
        let mask = 262144usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 262144usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved5(&self) -> ::std::os::raw::c_uint {
        let mask = 4294443008usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved5(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294443008usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(reserved1: ::std::os::raw::c_uint,
                          fixedTPM: ::std::os::raw::c_uint,
                          stClear: ::std::os::raw::c_uint,
                          reserved2: ::std::os::raw::c_uint,
                          fixedParent: ::std::os::raw::c_uint,
                          sensitiveDataOrigin: ::std::os::raw::c_uint,
                          userWithAuth: ::std::os::raw::c_uint,
                          adminWithPolicy: ::std::os::raw::c_uint,
                          reserved3: ::std::os::raw::c_uint,
                          noDA: ::std::os::raw::c_uint,
                          encryptedDuplication: ::std::os::raw::c_uint,
                          reserved4: ::std::os::raw::c_uint,
                          restricted: ::std::os::raw::c_uint,
                          decrypt: ::std::os::raw::c_uint,
                          sign: ::std::os::raw::c_uint,
                          reserved5: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              ({
                                                                                   ({
                                                                                        0
                                                                                    }
                                                                                        |
                                                                                        ((reserved1
                                                                                              as
                                                                                              u32
                                                                                              as
                                                                                              u32)
                                                                                             <<
                                                                                             0usize)
                                                                                            &
                                                                                            (1usize
                                                                                                 as
                                                                                                 u32))
                                                                               }
                                                                                   |
                                                                                   ((fixedTPM
                                                                                         as
                                                                                         u32
                                                                                         as
                                                                                         u32)
                                                                                        <<
                                                                                        1usize)
                                                                                       &
                                                                                       (2usize
                                                                                            as
                                                                                            u32))
                                                                          } |
                                                                              ((stClear
                                                                                    as
                                                                                    u32
                                                                                    as
                                                                                    u32)
                                                                                   <<
                                                                                   2usize)
                                                                                  &
                                                                                  (4usize
                                                                                       as
                                                                                       u32))
                                                                     } |
                                                                         ((reserved2
                                                                               as
                                                                               u32
                                                                               as
                                                                               u32)
                                                                              <<
                                                                              3usize)
                                                                             &
                                                                             (8usize
                                                                                  as
                                                                                  u32))
                                                                } |
                                                                    ((fixedParent
                                                                          as
                                                                          u32
                                                                          as
                                                                          u32)
                                                                         <<
                                                                         4usize)
                                                                        &
                                                                        (16usize
                                                                             as
                                                                             u32))
                                                           } |
                                                               ((sensitiveDataOrigin
                                                                     as u32 as
                                                                     u32) <<
                                                                    5usize) &
                                                                   (32usize as
                                                                        u32))
                                                      } |
                                                          ((userWithAuth as
                                                                u32 as u32) <<
                                                               6usize) &
                                                              (64usize as
                                                                   u32))
                                                 } |
                                                     ((adminWithPolicy as u32
                                                           as u32) << 7usize)
                                                         & (128usize as u32))
                                            } |
                                                ((reserved3 as u32 as u32) <<
                                                     8usize) &
                                                    (768usize as u32))
                                       } |
                                           ((noDA as u32 as u32) << 10usize) &
                                               (1024usize as u32))
                                  } |
                                      ((encryptedDuplication as u32 as u32) <<
                                           11usize) & (2048usize as u32))
                             } |
                                 ((reserved4 as u32 as u32) << 12usize) &
                                     (61440usize as u32))
                        } |
                            ((restricted as u32 as u32) << 16usize) &
                                (65536usize as u32))
                   } |
                       ((decrypt as u32 as u32) << 17usize) &
                           (131072usize as u32))
              } | ((sign as u32 as u32) << 18usize) & (262144usize as u32))
         } |
             ((reserved5 as u32 as u32) << 19usize) &
                 (4294443008usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_OBJECT() {
    assert_eq!(::std::mem::size_of::<TPMA_OBJECT>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_OBJECT ) ));
    assert_eq! (::std::mem::align_of::<TPMA_OBJECT>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_OBJECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_OBJECT ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_OBJECT ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_OBJECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_SESSION {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_SESSION__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_SESSION__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_SESSION__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_SESSION__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMA_SESSION__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_SESSION__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPMA_SESSION__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_SESSION__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_SESSION__bindgen_ty_1 {
    #[inline]
    pub fn continueSession(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_continueSession(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn auditExclusive(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_auditExclusive(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn auditReset(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_auditReset(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 24usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 24usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn decrypt(&self) -> ::std::os::raw::c_uint {
        let mask = 32usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_decrypt(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn encrypt(&self) -> ::std::os::raw::c_uint {
        let mask = 64usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_encrypt(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 64usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn audit(&self) -> ::std::os::raw::c_uint {
        let mask = 128usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_audit(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 128usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(continueSession: ::std::os::raw::c_uint,
                          auditExclusive: ::std::os::raw::c_uint,
                          auditReset: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          decrypt: ::std::os::raw::c_uint,
                          encrypt: ::std::os::raw::c_uint,
                          audit: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((continueSession as u32 as u8) <<
                                                0usize) & (1usize as u8))
                                  } |
                                      ((auditExclusive as u32 as u8) <<
                                           1usize) & (2usize as u8))
                             } |
                                 ((auditReset as u32 as u8) << 2usize) &
                                     (4usize as u8))
                        } |
                            ((reserved1 as u32 as u8) << 3usize) &
                                (24usize as u8))
                   } | ((decrypt as u32 as u8) << 5usize) & (32usize as u8))
              } | ((encrypt as u32 as u8) << 6usize) & (64usize as u8))
         } | ((audit as u32 as u8) << 7usize) & (128usize as u8))
    }
}
#[test]
fn bindgen_test_layout_TPMA_SESSION() {
    assert_eq!(::std::mem::size_of::<TPMA_SESSION>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_SESSION ) ));
    assert_eq! (::std::mem::align_of::<TPMA_SESSION>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_SESSION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_SESSION ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_SESSION ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_SESSION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_LOCALITY {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_LOCALITY__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_LOCALITY__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_LOCALITY__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_LOCALITY__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMA_LOCALITY__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_LOCALITY__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPMA_LOCALITY__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_LOCALITY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_LOCALITY__bindgen_ty_1 {
    #[inline]
    pub fn TPM_LOC_ZERO(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_LOC_ZERO(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPM_LOC_ONE(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_LOC_ONE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPM_LOC_TWO(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_LOC_TWO(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPM_LOC_THREE(&self) -> ::std::os::raw::c_uint {
        let mask = 8usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_LOC_THREE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPM_LOC_FOUR(&self) -> ::std::os::raw::c_uint {
        let mask = 16usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_LOC_FOUR(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn Extended(&self) -> ::std::os::raw::c_uint {
        let mask = 224usize as u8;
        let unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Extended(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 224usize as u8;
        let val = val as u32 as u8;
        let mut unit_field_val: u8 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(TPM_LOC_ZERO: ::std::os::raw::c_uint,
                          TPM_LOC_ONE: ::std::os::raw::c_uint,
                          TPM_LOC_TWO: ::std::os::raw::c_uint,
                          TPM_LOC_THREE: ::std::os::raw::c_uint,
                          TPM_LOC_FOUR: ::std::os::raw::c_uint,
                          Extended: ::std::os::raw::c_uint) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((TPM_LOC_ZERO as u32 as u8) << 0usize)
                                          & (1usize as u8))
                             } |
                                 ((TPM_LOC_ONE as u32 as u8) << 1usize) &
                                     (2usize as u8))
                        } |
                            ((TPM_LOC_TWO as u32 as u8) << 2usize) &
                                (4usize as u8))
                   } |
                       ((TPM_LOC_THREE as u32 as u8) << 3usize) &
                           (8usize as u8))
              } | ((TPM_LOC_FOUR as u32 as u8) << 4usize) & (16usize as u8))
         } | ((Extended as u32 as u8) << 5usize) & (224usize as u8))
    }
}
#[test]
fn bindgen_test_layout_TPMA_LOCALITY() {
    assert_eq!(::std::mem::size_of::<TPMA_LOCALITY>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_LOCALITY ) ));
    assert_eq! (::std::mem::align_of::<TPMA_LOCALITY>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_LOCALITY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_LOCALITY ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_LOCALITY ) , "::"
                , stringify ! ( val ) ));
}
impl Clone for TPMA_LOCALITY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_PERMANENT {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_PERMANENT__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_PERMANENT__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_PERMANENT__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_PERMANENT__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( TPMA_PERMANENT__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_PERMANENT__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_PERMANENT__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_PERMANENT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_PERMANENT__bindgen_ty_1 {
    #[inline]
    pub fn ownerAuthSet(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ownerAuthSet(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn endorsementAuthSet(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_endorsementAuthSet(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn lockoutAuthSet(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_lockoutAuthSet(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 248usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 248usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn disableClear(&self) -> ::std::os::raw::c_uint {
        let mask = 256usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_disableClear(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 256usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn inLockout(&self) -> ::std::os::raw::c_uint {
        let mask = 512usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_inLockout(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 512usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn tpmGeneratedEPS(&self) -> ::std::os::raw::c_uint {
        let mask = 1024usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_tpmGeneratedEPS(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> ::std::os::raw::c_uint {
        let mask = 4294965248usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294965248usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(ownerAuthSet: ::std::os::raw::c_uint,
                          endorsementAuthSet: ::std::os::raw::c_uint,
                          lockoutAuthSet: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          disableClear: ::std::os::raw::c_uint,
                          inLockout: ::std::os::raw::c_uint,
                          tpmGeneratedEPS: ::std::os::raw::c_uint,
                          reserved2: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((ownerAuthSet as u32 as u32)
                                                     << 0usize) &
                                                    (1usize as u32))
                                       } |
                                           ((endorsementAuthSet as u32 as u32)
                                                << 1usize) & (2usize as u32))
                                  } |
                                      ((lockoutAuthSet as u32 as u32) <<
                                           2usize) & (4usize as u32))
                             } |
                                 ((reserved1 as u32 as u32) << 3usize) &
                                     (248usize as u32))
                        } |
                            ((disableClear as u32 as u32) << 8usize) &
                                (256usize as u32))
                   } |
                       ((inLockout as u32 as u32) << 9usize) &
                           (512usize as u32))
              } |
                  ((tpmGeneratedEPS as u32 as u32) << 10usize) &
                      (1024usize as u32))
         } |
             ((reserved2 as u32 as u32) << 11usize) &
                 (4294965248usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_PERMANENT() {
    assert_eq!(::std::mem::size_of::<TPMA_PERMANENT>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_PERMANENT ) ));
    assert_eq! (::std::mem::align_of::<TPMA_PERMANENT>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_PERMANENT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_PERMANENT ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_PERMANENT ) , "::"
                , stringify ! ( val ) ));
}
impl Clone for TPMA_PERMANENT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_STARTUP_CLEAR {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_STARTUP_CLEAR__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_STARTUP_CLEAR__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_STARTUP_CLEAR__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_STARTUP_CLEAR__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_STARTUP_CLEAR__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPMA_STARTUP_CLEAR__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                TPMA_STARTUP_CLEAR__bindgen_ty_1 ) ));
}
impl Clone for TPMA_STARTUP_CLEAR__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_STARTUP_CLEAR__bindgen_ty_1 {
    #[inline]
    pub fn phEnable(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_phEnable(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn shEnable(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_shEnable(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn ehEnable(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ehEnable(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn phEnableNV(&self) -> ::std::os::raw::c_uint {
        let mask = 8usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_phEnableNV(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 2147483632usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2147483632usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn orderly(&self) -> ::std::os::raw::c_uint {
        let mask = 2147483648usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 31usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_orderly(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2147483648usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 31usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(phEnable: ::std::os::raw::c_uint,
                          shEnable: ::std::os::raw::c_uint,
                          ehEnable: ::std::os::raw::c_uint,
                          phEnableNV: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          orderly: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((phEnable as u32 as u32) << 0usize) &
                                          (1usize as u32))
                             } |
                                 ((shEnable as u32 as u32) << 1usize) &
                                     (2usize as u32))
                        } |
                            ((ehEnable as u32 as u32) << 2usize) &
                                (4usize as u32))
                   } |
                       ((phEnableNV as u32 as u32) << 3usize) &
                           (8usize as u32))
              } |
                  ((reserved1 as u32 as u32) << 4usize) &
                      (2147483632usize as u32))
         } | ((orderly as u32 as u32) << 31usize) & (2147483648usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_STARTUP_CLEAR() {
    assert_eq!(::std::mem::size_of::<TPMA_STARTUP_CLEAR>() , 4usize , concat !
               ( "Size of: " , stringify ! ( TPMA_STARTUP_CLEAR ) ));
    assert_eq! (::std::mem::align_of::<TPMA_STARTUP_CLEAR>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMA_STARTUP_CLEAR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_STARTUP_CLEAR ) ) . val as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_STARTUP_CLEAR ) ,
                "::" , stringify ! ( val ) ));
}
impl Clone for TPMA_STARTUP_CLEAR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_MEMORY {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_MEMORY__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_MEMORY__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_MEMORY__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_MEMORY__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMA_MEMORY__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_MEMORY__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMA_MEMORY__bindgen_ty_1 )
                ));
}
impl Clone for TPMA_MEMORY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_MEMORY__bindgen_ty_1 {
    #[inline]
    pub fn sharedRAM(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sharedRAM(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn sharedNV(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_sharedNV(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn objectCopiedToRam(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_objectCopiedToRam(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 4294967288usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967288usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(sharedRAM: ::std::os::raw::c_uint,
                          sharedNV: ::std::os::raw::c_uint,
                          objectCopiedToRam: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((sharedRAM as u32 as u32) << 0usize) &
                                (1usize as u32))
                   } | ((sharedNV as u32 as u32) << 1usize) & (2usize as u32))
              } |
                  ((objectCopiedToRam as u32 as u32) << 2usize) &
                      (4usize as u32))
         } | ((reserved1 as u32 as u32) << 3usize) & (4294967288usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_MEMORY() {
    assert_eq!(::std::mem::size_of::<TPMA_MEMORY>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_MEMORY ) ));
    assert_eq! (::std::mem::align_of::<TPMA_MEMORY>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_MEMORY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_MEMORY ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_MEMORY ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_MEMORY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_CC {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_CC__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_CC__bindgen_ty_1 {
    pub _bitfield_1: [u16; 2usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_CC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_CC__bindgen_ty_1>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( TPMA_CC__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPMA_CC__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMA_CC__bindgen_ty_1 ) ));
}
impl Clone for TPMA_CC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_CC__bindgen_ty_1 {
    #[inline]
    pub fn commandIndex(&self) -> ::std::os::raw::c_uint {
        let mask = 65535usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_commandIndex(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65535usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 4128768usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4128768usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn nv(&self) -> ::std::os::raw::c_uint {
        let mask = 4194304usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 22usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_nv(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4194304usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 22usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn extensive(&self) -> ::std::os::raw::c_uint {
        let mask = 8388608usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_extensive(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8388608usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn flushed(&self) -> ::std::os::raw::c_uint {
        let mask = 16777216usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_flushed(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777216usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn cHandles(&self) -> ::std::os::raw::c_uint {
        let mask = 234881024usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_cHandles(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 234881024usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn rHandle(&self) -> ::std::os::raw::c_uint {
        let mask = 268435456usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_rHandle(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 268435456usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn V(&self) -> ::std::os::raw::c_uint {
        let mask = 536870912usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 29usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 536870912usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 29usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn Res(&self) -> ::std::os::raw::c_uint {
        let mask = 3221225472usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 30usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_Res(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 3221225472usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 30usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(commandIndex: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          nv: ::std::os::raw::c_uint,
                          extensive: ::std::os::raw::c_uint,
                          flushed: ::std::os::raw::c_uint,
                          cHandles: ::std::os::raw::c_uint,
                          rHandle: ::std::os::raw::c_uint,
                          V: ::std::os::raw::c_uint,
                          Res: ::std::os::raw::c_uint) -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((commandIndex as u32 as
                                                           u32) << 0usize) &
                                                         (65535usize as u32))
                                            } |
                                                ((reserved1 as u32 as u32) <<
                                                     16usize) &
                                                    (4128768usize as u32))
                                       } |
                                           ((nv as u32 as u32) << 22usize) &
                                               (4194304usize as u32))
                                  } |
                                      ((extensive as u32 as u32) << 23usize) &
                                          (8388608usize as u32))
                             } |
                                 ((flushed as u32 as u32) << 24usize) &
                                     (16777216usize as u32))
                        } |
                            ((cHandles as u32 as u32) << 25usize) &
                                (234881024usize as u32))
                   } |
                       ((rHandle as u32 as u32) << 28usize) &
                           (268435456usize as u32))
              } | ((V as u32 as u32) << 29usize) & (536870912usize as u32))
         } | ((Res as u32 as u32) << 30usize) & (3221225472usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_CC() {
    assert_eq!(::std::mem::size_of::<TPMA_CC>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_CC ) ));
    assert_eq! (::std::mem::align_of::<TPMA_CC>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_CC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_CC ) ) . val as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_CC ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_CC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_MODES {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_MODES__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_MODES__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_MODES__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_MODES__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMA_MODES__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPMA_MODES__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMA_MODES__bindgen_ty_1 ) ));
}
impl Clone for TPMA_MODES__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_MODES__bindgen_ty_1 {
    #[inline]
    pub fn FIPS_140_2(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_FIPS_140_2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 4294967294usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4294967294usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(FIPS_140_2: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((FIPS_140_2 as u32 as u32) << 0usize) & (1usize as u32))
         } | ((reserved1 as u32 as u32) << 1usize) & (4294967294usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_MODES() {
    assert_eq!(::std::mem::size_of::<TPMA_MODES>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_MODES ) ));
    assert_eq! (::std::mem::align_of::<TPMA_MODES>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_MODES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_MODES ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_MODES ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_MODES {
    fn clone(&self) -> Self { *self }
}
pub type TPMI_YES_NO = BYTE;
pub type TPMI_DH_OBJECT = TPM_HANDLE;
pub type TPMI_DH_PERSISTENT = TPM_HANDLE;
pub type TPMI_DH_ENTITY = TPM_HANDLE;
pub type TPMI_DH_PCR = TPM_HANDLE;
pub type TPMI_SH_AUTH_SESSION = TPM_HANDLE;
pub type TPMI_SH_HMAC = TPM_HANDLE;
pub type TPMI_SH_POLICY = TPM_HANDLE;
pub type TPMI_DH_CONTEXT = TPM_HANDLE;
pub type TPMI_RH_HIERARCHY = TPM_HANDLE;
pub type TPMI_RH_ENABLES = TPM_HANDLE;
pub type TPMI_RH_HIERARCHY_AUTH = TPM_HANDLE;
pub type TPMI_RH_PLATFORM = TPM_HANDLE;
pub type TPMI_RH_OWNER = TPM_HANDLE;
pub type TPMI_RH_ENDORSEMENT = TPM_HANDLE;
pub type TPMI_RH_PROVISION = TPM_HANDLE;
pub type TPMI_RH_CLEAR = TPM_HANDLE;
pub type TPMI_RH_NV_AUTH = TPM_HANDLE;
pub type TPMI_RH_LOCKOUT = TPM_HANDLE;
pub type TPMI_RH_NV_INDEX = TPM_HANDLE;
pub type TPMI_ALG_HASH = TPM_ALG_ID;
pub type TPMI_ALG_ASYM = TPM_ALG_ID;
pub type TPMI_ALG_SYM = TPM_ALG_ID;
pub type TPMI_ALG_SYM_OBJECT = TPM_ALG_ID;
pub type TPMI_ALG_SYM_MODE = TPM_ALG_ID;
pub type TPMI_ALG_KDF = TPM_ALG_ID;
pub type TPMI_ALG_SIG_SCHEME = TPM_ALG_ID;
pub type TPMI_ECC_KEY_EXCHANGE = TPM_ALG_ID;
pub type TPMI_ST_COMMAND_TAG = TPM_ST;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_EMPTY {
    pub empty: __IncompleteArrayField<BYTE>,
}
#[test]
fn bindgen_test_layout_TPMS_EMPTY() {
    assert_eq!(::std::mem::size_of::<TPMS_EMPTY>() , 0usize , concat ! (
               "Size of: " , stringify ! ( TPMS_EMPTY ) ));
    assert_eq! (::std::mem::align_of::<TPMS_EMPTY>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_EMPTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_EMPTY ) ) . empty as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_EMPTY ) , "::" ,
                stringify ! ( empty ) ));
}
impl Clone for TPMS_EMPTY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ALGORITHM_DESCRIPTION {
    pub alg: TPM_ALG_ID,
    pub attributes: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DESCRIPTION() {
    assert_eq!(::std::mem::size_of::<TPMS_ALGORITHM_DESCRIPTION>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMS_ALGORITHM_DESCRIPTION ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ALGORITHM_DESCRIPTION>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPMS_ALGORITHM_DESCRIPTION )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DESCRIPTION ) ) . alg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DESCRIPTION ) , "::" , stringify ! ( alg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DESCRIPTION ) ) .
                attributes as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DESCRIPTION ) , "::" , stringify ! ( attributes
                ) ));
}
impl Clone for TPMS_ALGORITHM_DESCRIPTION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_HA {
    pub sha1: __BindgenUnionField<[BYTE; 20usize]>,
    pub sha256: __BindgenUnionField<[BYTE; 32usize]>,
    pub sha384: __BindgenUnionField<[BYTE; 48usize]>,
    pub sha512: __BindgenUnionField<[BYTE; 64usize]>,
    pub sm3_256: __BindgenUnionField<[BYTE; 32usize]>,
    pub bindgen_union_field: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_TPMU_HA() {
    assert_eq!(::std::mem::size_of::<TPMU_HA>() , 64usize , concat ! (
               "Size of: " , stringify ! ( TPMU_HA ) ));
    assert_eq! (::std::mem::align_of::<TPMU_HA>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_HA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_HA ) ) . sha1 as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_HA ) , "::" ,
                stringify ! ( sha1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_HA ) ) . sha256 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_HA ) , "::" ,
                stringify ! ( sha256 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_HA ) ) . sha384 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_HA ) , "::" ,
                stringify ! ( sha384 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_HA ) ) . sha512 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_HA ) , "::" ,
                stringify ! ( sha512 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_HA ) ) . sm3_256 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_HA ) , "::" ,
                stringify ! ( sm3_256 ) ));
}
impl Clone for TPMU_HA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_HA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_HA {
    pub hashAlg: TPMI_ALG_HASH,
    pub digest: TPMU_HA,
}
#[test]
fn bindgen_test_layout_TPMT_HA() {
    assert_eq!(::std::mem::size_of::<TPMT_HA>() , 66usize , concat ! (
               "Size of: " , stringify ! ( TPMT_HA ) ));
    assert_eq! (::std::mem::align_of::<TPMT_HA>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_HA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_HA ) ) . hashAlg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_HA ) , "::" ,
                stringify ! ( hashAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_HA ) ) . digest as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_HA ) , "::" ,
                stringify ! ( digest ) ));
}
impl Clone for TPMT_HA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_HA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_DIGEST {
    pub t: __BindgenUnionField<TPM2B_DIGEST__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 33usize],
}
#[repr(C)]
pub struct TPM2B_DIGEST__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_DIGEST__bindgen_ty_1>() , 66usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM2B_DIGEST__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_DIGEST__bindgen_ty_1>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM2B_DIGEST__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST__bindgen_ty_1 ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DIGEST__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST__bindgen_ty_1 ) ) . buffer
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DIGEST__bindgen_ty_1 ) , "::" , stringify ! ( buffer )
                ));
}
impl Default for TPM2B_DIGEST__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST() {
    assert_eq!(::std::mem::size_of::<TPM2B_DIGEST>() , 66usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_DIGEST ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_DIGEST>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_DIGEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DIGEST ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DIGEST ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_DIGEST {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_DIGEST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_DATA {
    pub t: __BindgenUnionField<TPM2B_DATA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 34usize],
}
#[repr(C)]
pub struct TPM2B_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 66usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DATA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_DATA__bindgen_ty_1>() , 68usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM2B_DATA__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_DATA__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_DATA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DATA__bindgen_ty_1 ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DATA__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DATA__bindgen_ty_1 ) ) . buffer as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DATA__bindgen_ty_1 ) , "::" , stringify ! ( buffer ) ));
}
impl Default for TPM2B_DATA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_DATA() {
    assert_eq!(::std::mem::size_of::<TPM2B_DATA>() , 68usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_DATA ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_DATA>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DATA ) ) . t as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DATA ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DATA ) ) . b as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DATA ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPM2B_NONCE = TPM2B_DIGEST;
pub type TPM2B_AUTH = TPM2B_DIGEST;
pub type TPM2B_OPERAND = TPM2B_DIGEST;
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_EVENT {
    pub t: __BindgenUnionField<TPM2B_EVENT__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 513usize],
}
#[repr(C)]
pub struct TPM2B_EVENT__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_EVENT__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_EVENT__bindgen_ty_1>() , 1026usize
               , concat ! (
               "Size of: " , stringify ! ( TPM2B_EVENT__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_EVENT__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_EVENT__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_EVENT__bindgen_ty_1 ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_EVENT__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_EVENT__bindgen_ty_1 ) ) . buffer as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_EVENT__bindgen_ty_1 ) , "::" , stringify ! ( buffer )
                ));
}
impl Default for TPM2B_EVENT__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_EVENT() {
    assert_eq!(::std::mem::size_of::<TPM2B_EVENT>() , 1026usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_EVENT ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_EVENT>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_EVENT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_EVENT ) ) . t as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_EVENT ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_EVENT ) ) . b as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_EVENT ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_EVENT {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_EVENT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_MAX_BUFFER {
    pub t: __BindgenUnionField<TPM2B_MAX_BUFFER__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 513usize],
}
#[repr(C)]
pub struct TPM2B_MAX_BUFFER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_BUFFER__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_BUFFER__bindgen_ty_1>() ,
               1026usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_MAX_BUFFER__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_BUFFER__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_MAX_BUFFER__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_BUFFER__bindgen_ty_1 ) ) . size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_BUFFER__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_BUFFER__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_BUFFER__bindgen_ty_1 ) , "::" , stringify ! ( buffer
                ) ));
}
impl Default for TPM2B_MAX_BUFFER__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_BUFFER() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_BUFFER>() , 1026usize , concat
               ! ( "Size of: " , stringify ! ( TPM2B_MAX_BUFFER ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_BUFFER>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPM2B_MAX_BUFFER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_BUFFER ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_BUFFER ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_BUFFER ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_BUFFER ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_MAX_BUFFER {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_MAX_BUFFER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_MAX_NV_BUFFER {
    pub t: __BindgenUnionField<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 513usize],
}
#[repr(C)]
pub struct TPM2B_MAX_NV_BUFFER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 1024usize],
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_NV_BUFFER__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>() ,
               1026usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_MAX_NV_BUFFER__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_NV_BUFFER__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_MAX_NV_BUFFER__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_NV_BUFFER__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_NV_BUFFER__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_NV_BUFFER__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_MAX_NV_BUFFER__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_MAX_NV_BUFFER__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_MAX_NV_BUFFER() {
    assert_eq!(::std::mem::size_of::<TPM2B_MAX_NV_BUFFER>() , 1026usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_MAX_NV_BUFFER )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_MAX_NV_BUFFER>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_MAX_NV_BUFFER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_NV_BUFFER ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_NV_BUFFER ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_MAX_NV_BUFFER ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_MAX_NV_BUFFER ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_MAX_NV_BUFFER {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_MAX_NV_BUFFER {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPM2B_TIMEOUT = TPM2B_DIGEST;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_IV {
    pub t: __BindgenUnionField<TPM2B_IV__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 9usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_IV__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout_TPM2B_IV__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_IV__bindgen_ty_1>() , 18usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_IV__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_IV__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_IV__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_IV__bindgen_ty_1 ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_IV__bindgen_ty_1
                ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_IV__bindgen_ty_1 ) ) . buffer as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_IV__bindgen_ty_1
                ) , "::" , stringify ! ( buffer ) ));
}
impl Clone for TPM2B_IV__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TPM2B_IV() {
    assert_eq!(::std::mem::size_of::<TPM2B_IV>() , 18usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_IV ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_IV>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_IV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_IV ) ) . t as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_IV ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_IV ) ) . b as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_IV ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_IV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_NAME {
    pub digest: __BindgenUnionField<TPMT_HA>,
    pub handle: __BindgenUnionField<TPM_HANDLE>,
    pub bindgen_union_field: [u32; 17usize],
}
#[test]
fn bindgen_test_layout_TPMU_NAME() {
    assert_eq!(::std::mem::size_of::<TPMU_NAME>() , 68usize , concat ! (
               "Size of: " , stringify ! ( TPMU_NAME ) ));
    assert_eq! (::std::mem::align_of::<TPMU_NAME>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_NAME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_NAME ) ) . digest as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_NAME ) , "::" ,
                stringify ! ( digest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_NAME ) ) . handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_NAME ) , "::" ,
                stringify ! ( handle ) ));
}
impl Clone for TPMU_NAME {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_NAME {
    pub t: __BindgenUnionField<TPM2B_NAME__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 35usize],
}
#[repr(C)]
pub struct TPM2B_NAME__bindgen_ty_1 {
    pub size: UINT16,
    pub name: [BYTE; 68usize],
}
#[test]
fn bindgen_test_layout_TPM2B_NAME__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_NAME__bindgen_ty_1>() , 70usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM2B_NAME__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_NAME__bindgen_ty_1>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_NAME__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NAME__bindgen_ty_1 ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_NAME__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NAME__bindgen_ty_1 ) ) . name as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_NAME__bindgen_ty_1 ) , "::" , stringify ! ( name ) ));
}
impl Default for TPM2B_NAME__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_NAME() {
    assert_eq!(::std::mem::size_of::<TPM2B_NAME>() , 70usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_NAME ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_NAME>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_NAME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NAME ) ) . t as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_NAME ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NAME ) ) . b as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_NAME ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_NAME {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_NAME {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_PCR_SELECT {
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECT() {
    assert_eq!(::std::mem::size_of::<TPMS_PCR_SELECT>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMS_PCR_SELECT ) ));
    assert_eq! (::std::mem::align_of::<TPMS_PCR_SELECT>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_PCR_SELECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_PCR_SELECT ) ) . sizeofSelect as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_PCR_SELECT ) ,
                "::" , stringify ! ( sizeofSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_PCR_SELECT ) ) . pcrSelect as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_PCR_SELECT ) ,
                "::" , stringify ! ( pcrSelect ) ));
}
impl Clone for TPMS_PCR_SELECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_PCR_SELECTION {
    pub hash: TPMI_ALG_HASH,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_PCR_SELECTION() {
    assert_eq!(::std::mem::size_of::<TPMS_PCR_SELECTION>() , 6usize , concat !
               ( "Size of: " , stringify ! ( TPMS_PCR_SELECTION ) ));
    assert_eq! (::std::mem::align_of::<TPMS_PCR_SELECTION>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_PCR_SELECTION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_PCR_SELECTION ) ) . hash as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_PCR_SELECTION ) ,
                "::" , stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_PCR_SELECTION ) ) . sizeofSelect as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_PCR_SELECTION ) ,
                "::" , stringify ! ( sizeofSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_PCR_SELECTION ) ) . pcrSelect as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_PCR_SELECTION ) ,
                "::" , stringify ! ( pcrSelect ) ));
}
impl Clone for TPMS_PCR_SELECTION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_TK_CREATION {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_CREATION() {
    assert_eq!(::std::mem::size_of::<TPMT_TK_CREATION>() , 76usize , concat !
               ( "Size of: " , stringify ! ( TPMT_TK_CREATION ) ));
    assert_eq! (::std::mem::align_of::<TPMT_TK_CREATION>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_TK_CREATION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_CREATION ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_CREATION ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_CREATION ) ) . hierarchy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_CREATION ) ,
                "::" , stringify ! ( hierarchy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_CREATION ) ) . digest as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_CREATION ) ,
                "::" , stringify ! ( digest ) ));
}
impl Clone for TPMT_TK_CREATION {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_TK_CREATION {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_TK_VERIFIED {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_VERIFIED() {
    assert_eq!(::std::mem::size_of::<TPMT_TK_VERIFIED>() , 76usize , concat !
               ( "Size of: " , stringify ! ( TPMT_TK_VERIFIED ) ));
    assert_eq! (::std::mem::align_of::<TPMT_TK_VERIFIED>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_TK_VERIFIED ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_VERIFIED ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_VERIFIED ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_VERIFIED ) ) . hierarchy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_VERIFIED ) ,
                "::" , stringify ! ( hierarchy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_VERIFIED ) ) . digest as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_VERIFIED ) ,
                "::" , stringify ! ( digest ) ));
}
impl Clone for TPMT_TK_VERIFIED {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_TK_VERIFIED {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_TK_AUTH {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_AUTH() {
    assert_eq!(::std::mem::size_of::<TPMT_TK_AUTH>() , 76usize , concat ! (
               "Size of: " , stringify ! ( TPMT_TK_AUTH ) ));
    assert_eq! (::std::mem::align_of::<TPMT_TK_AUTH>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_TK_AUTH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_AUTH ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_AUTH ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_AUTH ) ) . hierarchy as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_AUTH ) , "::" ,
                stringify ! ( hierarchy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_AUTH ) ) . digest as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_AUTH ) , "::" ,
                stringify ! ( digest ) ));
}
impl Clone for TPMT_TK_AUTH {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_TK_AUTH {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_TK_HASHCHECK {
    pub tag: TPM_ST,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub digest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMT_TK_HASHCHECK() {
    assert_eq!(::std::mem::size_of::<TPMT_TK_HASHCHECK>() , 76usize , concat !
               ( "Size of: " , stringify ! ( TPMT_TK_HASHCHECK ) ));
    assert_eq! (::std::mem::align_of::<TPMT_TK_HASHCHECK>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMT_TK_HASHCHECK ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_HASHCHECK ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_HASHCHECK ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_HASHCHECK ) ) . hierarchy as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_HASHCHECK ) ,
                "::" , stringify ! ( hierarchy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_TK_HASHCHECK ) ) . digest as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_TK_HASHCHECK ) ,
                "::" , stringify ! ( digest ) ));
}
impl Clone for TPMT_TK_HASHCHECK {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_TK_HASHCHECK {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ALG_PROPERTY {
    pub alg: TPM_ALG_ID,
    pub algProperties: TPMA_ALGORITHM,
}
#[test]
fn bindgen_test_layout_TPMS_ALG_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPMS_ALG_PROPERTY>() , 8usize , concat !
               ( "Size of: " , stringify ! ( TPMS_ALG_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ALG_PROPERTY>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_ALG_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALG_PROPERTY ) ) . alg as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ALG_PROPERTY ) ,
                "::" , stringify ! ( alg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALG_PROPERTY ) ) . algProperties as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ALG_PROPERTY ) ,
                "::" , stringify ! ( algProperties ) ));
}
impl Clone for TPMS_ALG_PROPERTY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_TAGGED_PROPERTY {
    pub property: TPM_PT,
    pub value: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPMS_TAGGED_PROPERTY>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_TAGGED_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPMS_TAGGED_PROPERTY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_TAGGED_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TAGGED_PROPERTY ) ) . property as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TAGGED_PROPERTY )
                , "::" , stringify ! ( property ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TAGGED_PROPERTY ) ) . value as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TAGGED_PROPERTY )
                , "::" , stringify ! ( value ) ));
}
impl Clone for TPMS_TAGGED_PROPERTY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_TAGGED_PCR_SELECT {
    pub tag: TPM_PT_PCR,
    pub sizeofSelect: UINT8,
    pub pcrSelect: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout_TPMS_TAGGED_PCR_SELECT() {
    assert_eq!(::std::mem::size_of::<TPMS_TAGGED_PCR_SELECT>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( TPMS_TAGGED_PCR_SELECT )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_TAGGED_PCR_SELECT>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_TAGGED_PCR_SELECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TAGGED_PCR_SELECT ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TAGGED_PCR_SELECT
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TAGGED_PCR_SELECT ) ) . sizeofSelect
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TAGGED_PCR_SELECT
                ) , "::" , stringify ! ( sizeofSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TAGGED_PCR_SELECT ) ) . pcrSelect as
                * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TAGGED_PCR_SELECT
                ) , "::" , stringify ! ( pcrSelect ) ));
}
impl Clone for TPMS_TAGGED_PCR_SELECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct TPML_CC {
    pub count: UINT32,
    pub commandCodes: [TPM_CC; 114usize],
}
#[test]
fn bindgen_test_layout_TPML_CC() {
    assert_eq!(::std::mem::size_of::<TPML_CC>() , 460usize , concat ! (
               "Size of: " , stringify ! ( TPML_CC ) ));
    assert_eq! (::std::mem::align_of::<TPML_CC>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_CC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_CC ) ) . count as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_CC ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_CC ) ) . commandCodes as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_CC ) , "::" ,
                stringify ! ( commandCodes ) ));
}
impl Default for TPML_CC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_CCA {
    pub count: UINT32,
    pub commandAttributes: [TPMA_CC; 114usize],
}
#[test]
fn bindgen_test_layout_TPML_CCA() {
    assert_eq!(::std::mem::size_of::<TPML_CCA>() , 460usize , concat ! (
               "Size of: " , stringify ! ( TPML_CCA ) ));
    assert_eq! (::std::mem::align_of::<TPML_CCA>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_CCA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_CCA ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_CCA ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_CCA ) ) . commandAttributes as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_CCA ) , "::" ,
                stringify ! ( commandAttributes ) ));
}
impl Default for TPML_CCA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_ALG {
    pub count: UINT32,
    pub algorithms: [TPM_ALG_ID; 64usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG() {
    assert_eq!(::std::mem::size_of::<TPML_ALG>() , 132usize , concat ! (
               "Size of: " , stringify ! ( TPML_ALG ) ));
    assert_eq! (::std::mem::align_of::<TPML_ALG>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_ALG ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ALG ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ALG ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ALG ) ) . algorithms as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ALG ) , "::" ,
                stringify ! ( algorithms ) ));
}
impl Default for TPML_ALG {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_HANDLE {
    pub count: UINT32,
    pub handle: [TPM_HANDLE; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_HANDLE() {
    assert_eq!(::std::mem::size_of::<TPML_HANDLE>() , 1020usize , concat ! (
               "Size of: " , stringify ! ( TPML_HANDLE ) ));
    assert_eq! (::std::mem::align_of::<TPML_HANDLE>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_HANDLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_HANDLE ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_HANDLE ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_HANDLE ) ) . handle as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_HANDLE ) , "::" ,
                stringify ! ( handle ) ));
}
impl Default for TPML_HANDLE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPML_DIGEST {
    pub count: UINT32,
    pub digests: [TPM2B_DIGEST; 8usize],
}
#[test]
fn bindgen_test_layout_TPML_DIGEST() {
    assert_eq!(::std::mem::size_of::<TPML_DIGEST>() , 532usize , concat ! (
               "Size of: " , stringify ! ( TPML_DIGEST ) ));
    assert_eq! (::std::mem::align_of::<TPML_DIGEST>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_DIGEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_DIGEST ) ) . count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_DIGEST ) , "::" ,
                stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_DIGEST ) ) . digests as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_DIGEST ) , "::" ,
                stringify ! ( digests ) ));
}
impl Clone for TPML_DIGEST {
    fn clone(&self) -> Self { *self }
}
impl Default for TPML_DIGEST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPML_DIGEST_VALUES {
    pub count: UINT32,
    pub digests: [TPMT_HA; 5usize],
}
#[test]
fn bindgen_test_layout_TPML_DIGEST_VALUES() {
    assert_eq!(::std::mem::size_of::<TPML_DIGEST_VALUES>() , 336usize , concat
               ! ( "Size of: " , stringify ! ( TPML_DIGEST_VALUES ) ));
    assert_eq! (::std::mem::align_of::<TPML_DIGEST_VALUES>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPML_DIGEST_VALUES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_DIGEST_VALUES ) ) . count as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_DIGEST_VALUES ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_DIGEST_VALUES ) ) . digests as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_DIGEST_VALUES ) ,
                "::" , stringify ! ( digests ) ));
}
impl Clone for TPML_DIGEST_VALUES {
    fn clone(&self) -> Self { *self }
}
impl Default for TPML_DIGEST_VALUES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_DIGEST_VALUES {
    pub t: __BindgenUnionField<TPM2B_DIGEST_VALUES__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 169usize],
}
#[repr(C)]
pub struct TPM2B_DIGEST_VALUES__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 336usize],
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST_VALUES__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_DIGEST_VALUES__bindgen_ty_1>() ,
               338usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_DIGEST_VALUES__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_DIGEST_VALUES__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_DIGEST_VALUES__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST_VALUES__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DIGEST_VALUES__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST_VALUES__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_DIGEST_VALUES__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_DIGEST_VALUES__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_DIGEST_VALUES() {
    assert_eq!(::std::mem::size_of::<TPM2B_DIGEST_VALUES>() , 338usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_DIGEST_VALUES )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_DIGEST_VALUES>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_DIGEST_VALUES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST_VALUES ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DIGEST_VALUES ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_DIGEST_VALUES ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_DIGEST_VALUES ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_DIGEST_VALUES {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_DIGEST_VALUES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPML_PCR_SELECTION {
    pub count: UINT32,
    pub pcrSelections: [TPMS_PCR_SELECTION; 5usize],
}
#[test]
fn bindgen_test_layout_TPML_PCR_SELECTION() {
    assert_eq!(::std::mem::size_of::<TPML_PCR_SELECTION>() , 36usize , concat
               ! ( "Size of: " , stringify ! ( TPML_PCR_SELECTION ) ));
    assert_eq! (::std::mem::align_of::<TPML_PCR_SELECTION>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPML_PCR_SELECTION ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_PCR_SELECTION ) ) . count as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_PCR_SELECTION ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_PCR_SELECTION ) ) . pcrSelections as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_PCR_SELECTION ) ,
                "::" , stringify ! ( pcrSelections ) ));
}
impl Clone for TPML_PCR_SELECTION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct TPML_ALG_PROPERTY {
    pub count: UINT32,
    pub algProperties: [TPMS_ALG_PROPERTY; 68usize],
}
#[test]
fn bindgen_test_layout_TPML_ALG_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPML_ALG_PROPERTY>() , 548usize , concat
               ! ( "Size of: " , stringify ! ( TPML_ALG_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPML_ALG_PROPERTY>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPML_ALG_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ALG_PROPERTY ) ) . count as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ALG_PROPERTY ) ,
                "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ALG_PROPERTY ) ) . algProperties as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ALG_PROPERTY ) ,
                "::" , stringify ! ( algProperties ) ));
}
impl Default for TPML_ALG_PROPERTY {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_TAGGED_TPM_PROPERTY {
    pub count: UINT32,
    pub tpmProperty: [TPMS_TAGGED_PROPERTY; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_TPM_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPML_TAGGED_TPM_PROPERTY>() , 1020usize ,
               concat ! (
               "Size of: " , stringify ! ( TPML_TAGGED_TPM_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPML_TAGGED_TPM_PROPERTY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPML_TAGGED_TPM_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_TAGGED_TPM_PROPERTY ) ) . count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPML_TAGGED_TPM_PROPERTY ) , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_TAGGED_TPM_PROPERTY ) ) .
                tpmProperty as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPML_TAGGED_TPM_PROPERTY ) , "::" , stringify ! ( tpmProperty
                ) ));
}
impl Default for TPML_TAGGED_TPM_PROPERTY {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_TAGGED_PCR_PROPERTY {
    pub count: UINT32,
    pub pcrProperty: [TPMS_TAGGED_PCR_SELECT; 127usize],
}
#[test]
fn bindgen_test_layout_TPML_TAGGED_PCR_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPML_TAGGED_PCR_PROPERTY>() , 1020usize ,
               concat ! (
               "Size of: " , stringify ! ( TPML_TAGGED_PCR_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPML_TAGGED_PCR_PROPERTY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPML_TAGGED_PCR_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_TAGGED_PCR_PROPERTY ) ) . count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPML_TAGGED_PCR_PROPERTY ) , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_TAGGED_PCR_PROPERTY ) ) .
                pcrProperty as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPML_TAGGED_PCR_PROPERTY ) , "::" , stringify ! ( pcrProperty
                ) ));
}
impl Default for TPML_TAGGED_PCR_PROPERTY {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_ECC_CURVE {
    pub count: UINT32,
    pub eccCurves: [TPM_ECC_CURVE; 508usize],
}
#[test]
fn bindgen_test_layout_TPML_ECC_CURVE() {
    assert_eq!(::std::mem::size_of::<TPML_ECC_CURVE>() , 1020usize , concat !
               ( "Size of: " , stringify ! ( TPML_ECC_CURVE ) ));
    assert_eq! (::std::mem::align_of::<TPML_ECC_CURVE>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPML_ECC_CURVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ECC_CURVE ) ) . count as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ECC_CURVE ) , "::"
                , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_ECC_CURVE ) ) . eccCurves as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_ECC_CURVE ) , "::"
                , stringify ! ( eccCurves ) ));
}
impl Default for TPML_ECC_CURVE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
pub struct TPML_INTEL_PTT_PROPERTY {
    pub count: UINT32,
    pub property: [UINT32; 254usize],
}
#[test]
fn bindgen_test_layout_TPML_INTEL_PTT_PROPERTY() {
    assert_eq!(::std::mem::size_of::<TPML_INTEL_PTT_PROPERTY>() , 1020usize ,
               concat ! (
               "Size of: " , stringify ! ( TPML_INTEL_PTT_PROPERTY ) ));
    assert_eq! (::std::mem::align_of::<TPML_INTEL_PTT_PROPERTY>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPML_INTEL_PTT_PROPERTY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_INTEL_PTT_PROPERTY ) ) . count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_INTEL_PTT_PROPERTY
                ) , "::" , stringify ! ( count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPML_INTEL_PTT_PROPERTY ) ) . property as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPML_INTEL_PTT_PROPERTY
                ) , "::" , stringify ! ( property ) ));
}
impl Default for TPML_INTEL_PTT_PROPERTY {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_CAPABILITIES {
    pub algorithms: __BindgenUnionField<TPML_ALG_PROPERTY>,
    pub handles: __BindgenUnionField<TPML_HANDLE>,
    pub command: __BindgenUnionField<TPML_CCA>,
    pub ppCommands: __BindgenUnionField<TPML_CC>,
    pub auditCommands: __BindgenUnionField<TPML_CC>,
    pub assignedPCR: __BindgenUnionField<TPML_PCR_SELECTION>,
    pub tpmProperties: __BindgenUnionField<TPML_TAGGED_TPM_PROPERTY>,
    pub pcrProperties: __BindgenUnionField<TPML_TAGGED_PCR_PROPERTY>,
    pub eccCurves: __BindgenUnionField<TPML_ECC_CURVE>,
    pub intelPttProperty: __BindgenUnionField<TPML_INTEL_PTT_PROPERTY>,
    pub bindgen_union_field: [u32; 255usize],
}
#[test]
fn bindgen_test_layout_TPMU_CAPABILITIES() {
    assert_eq!(::std::mem::size_of::<TPMU_CAPABILITIES>() , 1020usize , concat
               ! ( "Size of: " , stringify ! ( TPMU_CAPABILITIES ) ));
    assert_eq! (::std::mem::align_of::<TPMU_CAPABILITIES>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMU_CAPABILITIES ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . algorithms as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( algorithms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . handles as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( handles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . command as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . ppCommands as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( ppCommands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . auditCommands as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( auditCommands ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . assignedPCR as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( assignedPCR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . tpmProperties as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( tpmProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . pcrProperties as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( pcrProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . eccCurves as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( eccCurves ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_CAPABILITIES ) ) . intelPttProperty
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_CAPABILITIES ) ,
                "::" , stringify ! ( intelPttProperty ) ));
}
impl Clone for TPMU_CAPABILITIES {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_CAPABILITIES {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CAPABILITY_DATA {
    pub capability: TPM_CAP,
    pub data: TPMU_CAPABILITIES,
}
#[test]
fn bindgen_test_layout_TPMS_CAPABILITY_DATA() {
    assert_eq!(::std::mem::size_of::<TPMS_CAPABILITY_DATA>() , 1024usize ,
               concat ! ( "Size of: " , stringify ! ( TPMS_CAPABILITY_DATA )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_CAPABILITY_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_CAPABILITY_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CAPABILITY_DATA ) ) . capability as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CAPABILITY_DATA )
                , "::" , stringify ! ( capability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CAPABILITY_DATA ) ) . data as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CAPABILITY_DATA )
                , "::" , stringify ! ( data ) ));
}
impl Clone for TPMS_CAPABILITY_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CAPABILITY_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_CLOCK_INFO {
    pub clock: UINT64,
    pub resetCount: UINT32,
    pub restartCount: UINT32,
    pub safe: TPMI_YES_NO,
}
#[test]
fn bindgen_test_layout_TPMS_CLOCK_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_CLOCK_INFO>() , 24usize , concat ! (
               "Size of: " , stringify ! ( TPMS_CLOCK_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CLOCK_INFO>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_CLOCK_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CLOCK_INFO ) ) . clock as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CLOCK_INFO ) ,
                "::" , stringify ! ( clock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CLOCK_INFO ) ) . resetCount as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CLOCK_INFO ) ,
                "::" , stringify ! ( resetCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CLOCK_INFO ) ) . restartCount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CLOCK_INFO ) ,
                "::" , stringify ! ( restartCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CLOCK_INFO ) ) . safe as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CLOCK_INFO ) ,
                "::" , stringify ! ( safe ) ));
}
impl Clone for TPMS_CLOCK_INFO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_TIME_INFO {
    pub time: UINT64,
    pub clockInfo: TPMS_CLOCK_INFO,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_TIME_INFO>() , 32usize , concat ! (
               "Size of: " , stringify ! ( TPMS_TIME_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_TIME_INFO>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_TIME_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TIME_INFO ) ) . time as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TIME_INFO ) , "::"
                , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TIME_INFO ) ) . clockInfo as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TIME_INFO ) , "::"
                , stringify ! ( clockInfo ) ));
}
impl Clone for TPMS_TIME_INFO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_TIME_ATTEST_INFO {
    pub time: TPMS_TIME_INFO,
    pub firmwareVersion: UINT64,
}
#[test]
fn bindgen_test_layout_TPMS_TIME_ATTEST_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_TIME_ATTEST_INFO>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( TPMS_TIME_ATTEST_INFO )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_TIME_ATTEST_INFO>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_TIME_ATTEST_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TIME_ATTEST_INFO ) ) . time as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TIME_ATTEST_INFO )
                , "::" , stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_TIME_ATTEST_INFO ) ) .
                firmwareVersion as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_TIME_ATTEST_INFO )
                , "::" , stringify ! ( firmwareVersion ) ));
}
impl Clone for TPMS_TIME_ATTEST_INFO {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CERTIFY_INFO {
    pub name: TPM2B_NAME,
    pub qualifiedName: TPM2B_NAME,
}
#[test]
fn bindgen_test_layout_TPMS_CERTIFY_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_CERTIFY_INFO>() , 140usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_CERTIFY_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CERTIFY_INFO>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_CERTIFY_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CERTIFY_INFO ) ) . name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CERTIFY_INFO ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CERTIFY_INFO ) ) . qualifiedName as
                * const _ as usize } , 70usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CERTIFY_INFO ) ,
                "::" , stringify ! ( qualifiedName ) ));
}
impl Clone for TPMS_CERTIFY_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CERTIFY_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_QUOTE_INFO {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_QUOTE_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_QUOTE_INFO>() , 104usize , concat !
               ( "Size of: " , stringify ! ( TPMS_QUOTE_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_QUOTE_INFO>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_QUOTE_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_QUOTE_INFO ) ) . pcrSelect as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_QUOTE_INFO ) ,
                "::" , stringify ! ( pcrSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_QUOTE_INFO ) ) . pcrDigest as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_QUOTE_INFO ) ,
                "::" , stringify ! ( pcrDigest ) ));
}
impl Clone for TPMS_QUOTE_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_QUOTE_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_COMMAND_AUDIT_INFO {
    pub auditCounter: UINT64,
    pub digestAlg: TPM_ALG_ID,
    pub auditDigest: TPM2B_DIGEST,
    pub commandDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_COMMAND_AUDIT_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_COMMAND_AUDIT_INFO>() , 144usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMS_COMMAND_AUDIT_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_COMMAND_AUDIT_INFO>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_COMMAND_AUDIT_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_COMMAND_AUDIT_INFO ) ) .
                auditCounter as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_COMMAND_AUDIT_INFO
                ) , "::" , stringify ! ( auditCounter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_COMMAND_AUDIT_INFO ) ) . digestAlg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_COMMAND_AUDIT_INFO
                ) , "::" , stringify ! ( digestAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_COMMAND_AUDIT_INFO ) ) . auditDigest
                as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_COMMAND_AUDIT_INFO
                ) , "::" , stringify ! ( auditDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_COMMAND_AUDIT_INFO ) ) .
                commandDigest as * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_COMMAND_AUDIT_INFO
                ) , "::" , stringify ! ( commandDigest ) ));
}
impl Clone for TPMS_COMMAND_AUDIT_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_COMMAND_AUDIT_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_SESSION_AUDIT_INFO {
    pub exclusiveSession: TPMI_YES_NO,
    pub sessionDigest: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_SESSION_AUDIT_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_SESSION_AUDIT_INFO>() , 68usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMS_SESSION_AUDIT_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SESSION_AUDIT_INFO>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_SESSION_AUDIT_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SESSION_AUDIT_INFO ) ) .
                exclusiveSession as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SESSION_AUDIT_INFO
                ) , "::" , stringify ! ( exclusiveSession ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SESSION_AUDIT_INFO ) ) .
                sessionDigest as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SESSION_AUDIT_INFO
                ) , "::" , stringify ! ( sessionDigest ) ));
}
impl Clone for TPMS_SESSION_AUDIT_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_SESSION_AUDIT_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CREATION_INFO {
    pub objectName: TPM2B_NAME,
    pub creationHash: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_CREATION_INFO>() , 136usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_CREATION_INFO ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CREATION_INFO>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_CREATION_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_INFO ) ) . objectName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_INFO ) ,
                "::" , stringify ! ( objectName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_INFO ) ) . creationHash as
                * const _ as usize } , 70usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_INFO ) ,
                "::" , stringify ! ( creationHash ) ));
}
impl Clone for TPMS_CREATION_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CREATION_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_NV_CERTIFY_INFO {
    pub indexName: TPM2B_NAME,
    pub offset: UINT16,
    pub nvContents: TPM2B_MAX_NV_BUFFER,
}
#[test]
fn bindgen_test_layout_TPMS_NV_CERTIFY_INFO() {
    assert_eq!(::std::mem::size_of::<TPMS_NV_CERTIFY_INFO>() , 1098usize ,
               concat ! ( "Size of: " , stringify ! ( TPMS_NV_CERTIFY_INFO )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_NV_CERTIFY_INFO>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_NV_CERTIFY_INFO ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_CERTIFY_INFO ) ) . indexName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_CERTIFY_INFO )
                , "::" , stringify ! ( indexName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_CERTIFY_INFO ) ) . offset as *
                const _ as usize } , 70usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_CERTIFY_INFO )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_CERTIFY_INFO ) ) . nvContents as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_CERTIFY_INFO )
                , "::" , stringify ! ( nvContents ) ));
}
impl Clone for TPMS_NV_CERTIFY_INFO {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_NV_CERTIFY_INFO {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMI_ST_ATTEST = TPM_ST;
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_ATTEST {
    pub certify: __BindgenUnionField<TPMS_CERTIFY_INFO>,
    pub creation: __BindgenUnionField<TPMS_CREATION_INFO>,
    pub quote: __BindgenUnionField<TPMS_QUOTE_INFO>,
    pub commandAudit: __BindgenUnionField<TPMS_COMMAND_AUDIT_INFO>,
    pub sessionAudit: __BindgenUnionField<TPMS_SESSION_AUDIT_INFO>,
    pub time: __BindgenUnionField<TPMS_TIME_ATTEST_INFO>,
    pub nv: __BindgenUnionField<TPMS_NV_CERTIFY_INFO>,
    pub bindgen_union_field: [u64; 138usize],
}
#[test]
fn bindgen_test_layout_TPMU_ATTEST() {
    assert_eq!(::std::mem::size_of::<TPMU_ATTEST>() , 1104usize , concat ! (
               "Size of: " , stringify ! ( TPMU_ATTEST ) ));
    assert_eq! (::std::mem::align_of::<TPMU_ATTEST>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_ATTEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . certify as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( certify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . creation as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( creation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . quote as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( quote ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . commandAudit as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( commandAudit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . sessionAudit as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( sessionAudit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . time as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ATTEST ) ) . nv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ATTEST ) , "::" ,
                stringify ! ( nv ) ));
}
impl Clone for TPMU_ATTEST {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_ATTEST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_ATTEST {
    pub magic: TPM_GENERATED,
    pub type_: TPMI_ST_ATTEST,
    pub qualifiedSigner: TPM2B_NAME,
    pub extraData: TPM2B_DATA,
    pub clockInfo: TPMS_CLOCK_INFO,
    pub firmwareVersion: UINT64,
    pub attested: TPMU_ATTEST,
}
#[test]
fn bindgen_test_layout_TPMS_ATTEST() {
    assert_eq!(::std::mem::size_of::<TPMS_ATTEST>() , 1280usize , concat ! (
               "Size of: " , stringify ! ( TPMS_ATTEST ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ATTEST>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_ATTEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . magic as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . type_ as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . qualifiedSigner as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( qualifiedSigner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . extraData as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( extraData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . clockInfo as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( clockInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . firmwareVersion as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( firmwareVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ATTEST ) ) . attested as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ATTEST ) , "::" ,
                stringify ! ( attested ) ));
}
impl Clone for TPMS_ATTEST {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_ATTEST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_ATTEST {
    pub t: __BindgenUnionField<TPM2B_ATTEST__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 641usize],
}
#[repr(C)]
pub struct TPM2B_ATTEST__bindgen_ty_1 {
    pub size: UINT16,
    pub attestationData: [BYTE; 1280usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ATTEST__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_ATTEST__bindgen_ty_1>() , 1282usize
               , concat ! (
               "Size of: " , stringify ! ( TPM2B_ATTEST__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ATTEST__bindgen_ty_1>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM2B_ATTEST__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ATTEST__bindgen_ty_1 ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ATTEST__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ATTEST__bindgen_ty_1 ) ) .
                attestationData as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ATTEST__bindgen_ty_1 ) , "::" , stringify ! (
                attestationData ) ));
}
impl Default for TPM2B_ATTEST__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_ATTEST() {
    assert_eq!(::std::mem::size_of::<TPM2B_ATTEST>() , 1282usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_ATTEST ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ATTEST>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_ATTEST ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ATTEST ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ATTEST ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ATTEST ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ATTEST ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_ATTEST {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_ATTEST {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_AUTH_COMMAND {
    pub sessionHandle: TPMI_SH_AUTH_SESSION,
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_COMMAND() {
    assert_eq!(::std::mem::size_of::<TPMS_AUTH_COMMAND>() , 144usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_AUTH_COMMAND ) ));
    assert_eq! (::std::mem::align_of::<TPMS_AUTH_COMMAND>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_AUTH_COMMAND ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_COMMAND ) ) . sessionHandle as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_COMMAND ) ,
                "::" , stringify ! ( sessionHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_COMMAND ) ) . nonce as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_COMMAND ) ,
                "::" , stringify ! ( nonce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_COMMAND ) ) . sessionAttributes
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_COMMAND ) ,
                "::" , stringify ! ( sessionAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_COMMAND ) ) . hmac as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_COMMAND ) ,
                "::" , stringify ! ( hmac ) ));
}
impl Clone for TPMS_AUTH_COMMAND {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_AUTH_COMMAND {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_AUTH_RESPONSE {
    pub nonce: TPM2B_NONCE,
    pub sessionAttributes: TPMA_SESSION,
    pub hmac: TPM2B_AUTH,
}
#[test]
fn bindgen_test_layout_TPMS_AUTH_RESPONSE() {
    assert_eq!(::std::mem::size_of::<TPMS_AUTH_RESPONSE>() , 140usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_AUTH_RESPONSE ) ));
    assert_eq! (::std::mem::align_of::<TPMS_AUTH_RESPONSE>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_AUTH_RESPONSE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_RESPONSE ) ) . nonce as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_RESPONSE ) ,
                "::" , stringify ! ( nonce ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_RESPONSE ) ) .
                sessionAttributes as * const _ as usize } , 68usize , concat !
                (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_RESPONSE ) ,
                "::" , stringify ! ( sessionAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_AUTH_RESPONSE ) ) . hmac as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_AUTH_RESPONSE ) ,
                "::" , stringify ! ( hmac ) ));
}
impl Clone for TPMS_AUTH_RESPONSE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_AUTH_RESPONSE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMI_AES_KEY_BITS = TPM_KEY_BITS;
pub type TPMI_SM4_KEY_BITS = TPM_KEY_BITS;
pub type TPMI_CAMELLIA_KEY_BITS = TPM_KEY_BITS;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_SYM_KEY_BITS {
    pub aes: __BindgenUnionField<TPMI_AES_KEY_BITS>,
    pub sm4: __BindgenUnionField<TPMI_SM4_KEY_BITS>,
    pub sym: __BindgenUnionField<TPM_KEY_BITS>,
    pub exclusiveOr: __BindgenUnionField<TPMI_ALG_HASH>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_KEY_BITS() {
    assert_eq!(::std::mem::size_of::<TPMU_SYM_KEY_BITS>() , 2usize , concat !
               ( "Size of: " , stringify ! ( TPMU_SYM_KEY_BITS ) ));
    assert_eq! (::std::mem::align_of::<TPMU_SYM_KEY_BITS>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMU_SYM_KEY_BITS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_KEY_BITS ) ) . aes as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_KEY_BITS ) ,
                "::" , stringify ! ( aes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_KEY_BITS ) ) . sm4 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_KEY_BITS ) ,
                "::" , stringify ! ( sm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_KEY_BITS ) ) . sym as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_KEY_BITS ) ,
                "::" , stringify ! ( sym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_KEY_BITS ) ) . exclusiveOr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_KEY_BITS ) ,
                "::" , stringify ! ( exclusiveOr ) ));
}
impl Clone for TPMU_SYM_KEY_BITS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_SYM_MODE {
    pub aes: __BindgenUnionField<TPMI_ALG_SYM_MODE>,
    pub sm4: __BindgenUnionField<TPMI_ALG_SYM_MODE>,
    pub sym: __BindgenUnionField<TPMI_ALG_SYM_MODE>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_TPMU_SYM_MODE() {
    assert_eq!(::std::mem::size_of::<TPMU_SYM_MODE>() , 2usize , concat ! (
               "Size of: " , stringify ! ( TPMU_SYM_MODE ) ));
    assert_eq! (::std::mem::align_of::<TPMU_SYM_MODE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_SYM_MODE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_MODE ) ) . aes as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_MODE ) , "::"
                , stringify ! ( aes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_MODE ) ) . sm4 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_MODE ) , "::"
                , stringify ! ( sm4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SYM_MODE ) ) . sym as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SYM_MODE ) , "::"
                , stringify ! ( sym ) ));
}
impl Clone for TPMU_SYM_MODE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_SYM_DEF {
    pub algorithm: TPMI_ALG_SYM,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF() {
    assert_eq!(::std::mem::size_of::<TPMT_SYM_DEF>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_SYM_DEF ) ));
    assert_eq! (::std::mem::align_of::<TPMT_SYM_DEF>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_SYM_DEF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF ) ) . algorithm as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF ) , "::" ,
                stringify ! ( algorithm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF ) ) . keyBits as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF ) , "::" ,
                stringify ! ( keyBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF ) ) . mode as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF ) , "::" ,
                stringify ! ( mode ) ));
}
impl Clone for TPMT_SYM_DEF {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_SYM_DEF_OBJECT {
    pub algorithm: TPMI_ALG_SYM_OBJECT,
    pub keyBits: TPMU_SYM_KEY_BITS,
    pub mode: TPMU_SYM_MODE,
}
#[test]
fn bindgen_test_layout_TPMT_SYM_DEF_OBJECT() {
    assert_eq!(::std::mem::size_of::<TPMT_SYM_DEF_OBJECT>() , 6usize , concat
               ! ( "Size of: " , stringify ! ( TPMT_SYM_DEF_OBJECT ) ));
    assert_eq! (::std::mem::align_of::<TPMT_SYM_DEF_OBJECT>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMT_SYM_DEF_OBJECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF_OBJECT ) ) . algorithm as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF_OBJECT ) ,
                "::" , stringify ! ( algorithm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF_OBJECT ) ) . keyBits as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF_OBJECT ) ,
                "::" , stringify ! ( keyBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SYM_DEF_OBJECT ) ) . mode as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SYM_DEF_OBJECT ) ,
                "::" , stringify ! ( mode ) ));
}
impl Clone for TPMT_SYM_DEF_OBJECT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_SYM_KEY {
    pub t: __BindgenUnionField<TPM2B_SYM_KEY__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 17usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_SYM_KEY__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SYM_KEY__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_SYM_KEY__bindgen_ty_1>() , 34usize
               , concat ! (
               "Size of: " , stringify ! ( TPM2B_SYM_KEY__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SYM_KEY__bindgen_ty_1>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM2B_SYM_KEY__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SYM_KEY__bindgen_ty_1 ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SYM_KEY__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SYM_KEY__bindgen_ty_1 ) ) . buffer
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SYM_KEY__bindgen_ty_1 ) , "::" , stringify ! ( buffer )
                ));
}
impl Clone for TPM2B_SYM_KEY__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TPM2B_SYM_KEY() {
    assert_eq!(::std::mem::size_of::<TPM2B_SYM_KEY>() , 34usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_SYM_KEY ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SYM_KEY>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_SYM_KEY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SYM_KEY ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SYM_KEY ) , "::"
                , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SYM_KEY ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SYM_KEY ) , "::"
                , stringify ! ( b ) ));
}
impl Clone for TPM2B_SYM_KEY {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_SYMCIPHER_PARMS {
    pub sym: TPMT_SYM_DEF_OBJECT,
}
#[test]
fn bindgen_test_layout_TPMS_SYMCIPHER_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMS_SYMCIPHER_PARMS>() , 6usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_SYMCIPHER_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SYMCIPHER_PARMS>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_SYMCIPHER_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SYMCIPHER_PARMS ) ) . sym as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SYMCIPHER_PARMS )
                , "::" , stringify ! ( sym ) ));
}
impl Clone for TPMS_SYMCIPHER_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_SENSITIVE_DATA {
    pub t: __BindgenUnionField<TPM2B_SENSITIVE_DATA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 65usize],
}
#[repr(C)]
pub struct TPM2B_SENSITIVE_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_DATA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>() ,
               130usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_SENSITIVE_DATA__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE_DATA__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_SENSITIVE_DATA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_DATA__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE_DATA__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_DATA__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE_DATA__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_SENSITIVE_DATA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_DATA() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE_DATA>() , 130usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_SENSITIVE_DATA )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE_DATA>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_SENSITIVE_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_DATA ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE_DATA )
                , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_DATA ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE_DATA )
                , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_SENSITIVE_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_SENSITIVE_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_SENSITIVE_CREATE {
    pub userAuth: TPM2B_AUTH,
    pub data: TPM2B_SENSITIVE_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_SENSITIVE_CREATE() {
    assert_eq!(::std::mem::size_of::<TPMS_SENSITIVE_CREATE>() , 196usize ,
               concat ! ( "Size of: " , stringify ! ( TPMS_SENSITIVE_CREATE )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_SENSITIVE_CREATE>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_SENSITIVE_CREATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SENSITIVE_CREATE ) ) . userAuth as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SENSITIVE_CREATE )
                , "::" , stringify ! ( userAuth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SENSITIVE_CREATE ) ) . data as *
                const _ as usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SENSITIVE_CREATE )
                , "::" , stringify ! ( data ) ));
}
impl Clone for TPMS_SENSITIVE_CREATE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_SENSITIVE_CREATE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_SENSITIVE_CREATE {
    pub t: __BindgenUnionField<TPM2B_SENSITIVE_CREATE__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 99usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_SENSITIVE_CREATE__bindgen_ty_1 {
    pub size: UINT16,
    pub sensitive: TPMS_SENSITIVE_CREATE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_CREATE__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE_CREATE__bindgen_ty_1>() ,
               198usize , concat ! (
               "Size of: " , stringify ! (
               TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE_CREATE__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) )
                . size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) )
                . sensitive as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE_CREATE__bindgen_ty_1 ) , "::" , stringify ! (
                sensitive ) ));
}
impl Clone for TPM2B_SENSITIVE_CREATE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_SENSITIVE_CREATE__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE_CREATE() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE_CREATE>() , 198usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_SENSITIVE_CREATE )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE_CREATE>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_SENSITIVE_CREATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_CREATE ) ) . t as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE_CREATE
                ) , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE_CREATE ) ) . b as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE_CREATE
                ) , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_SENSITIVE_CREATE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_SENSITIVE_CREATE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_SCHEME_HASH {
    pub hashAlg: TPMI_ALG_HASH,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_HASH() {
    assert_eq!(::std::mem::size_of::<TPMS_SCHEME_HASH>() , 2usize , concat ! (
               "Size of: " , stringify ! ( TPMS_SCHEME_HASH ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SCHEME_HASH>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_SCHEME_HASH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SCHEME_HASH ) ) . hashAlg as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SCHEME_HASH ) ,
                "::" , stringify ! ( hashAlg ) ));
}
impl Clone for TPMS_SCHEME_HASH {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_SCHEME_ECDAA {
    pub hashAlg: TPMI_ALG_HASH,
    pub count: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_ECDAA() {
    assert_eq!(::std::mem::size_of::<TPMS_SCHEME_ECDAA>() , 4usize , concat !
               ( "Size of: " , stringify ! ( TPMS_SCHEME_ECDAA ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SCHEME_ECDAA>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_SCHEME_ECDAA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SCHEME_ECDAA ) ) . hashAlg as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SCHEME_ECDAA ) ,
                "::" , stringify ! ( hashAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SCHEME_ECDAA ) ) . count as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SCHEME_ECDAA ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for TPMS_SCHEME_ECDAA {
    fn clone(&self) -> Self { *self }
}
pub type TPMI_ALG_KEYEDHASH_SCHEME = TPM_ALG_ID;
pub type TPMS_SCHEME_HMAC = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_SCHEME_XOR {
    pub hashAlg: TPMI_ALG_HASH,
    pub kdf: TPMI_ALG_KDF,
}
#[test]
fn bindgen_test_layout_TPMS_SCHEME_XOR() {
    assert_eq!(::std::mem::size_of::<TPMS_SCHEME_XOR>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMS_SCHEME_XOR ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SCHEME_XOR>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_SCHEME_XOR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SCHEME_XOR ) ) . hashAlg as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SCHEME_XOR ) ,
                "::" , stringify ! ( hashAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SCHEME_XOR ) ) . kdf as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SCHEME_XOR ) ,
                "::" , stringify ! ( kdf ) ));
}
impl Clone for TPMS_SCHEME_XOR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_SCHEME_KEYEDHASH {
    pub hmac: __BindgenUnionField<TPMS_SCHEME_HMAC>,
    pub exclusiveOr: __BindgenUnionField<TPMS_SCHEME_XOR>,
    pub bindgen_union_field: [u16; 2usize],
}
#[test]
fn bindgen_test_layout_TPMU_SCHEME_KEYEDHASH() {
    assert_eq!(::std::mem::size_of::<TPMU_SCHEME_KEYEDHASH>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( TPMU_SCHEME_KEYEDHASH )
               ));
    assert_eq! (::std::mem::align_of::<TPMU_SCHEME_KEYEDHASH>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMU_SCHEME_KEYEDHASH ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SCHEME_KEYEDHASH ) ) . hmac as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SCHEME_KEYEDHASH )
                , "::" , stringify ! ( hmac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SCHEME_KEYEDHASH ) ) . exclusiveOr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SCHEME_KEYEDHASH )
                , "::" , stringify ! ( exclusiveOr ) ));
}
impl Clone for TPMU_SCHEME_KEYEDHASH {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_KEYEDHASH_SCHEME {
    pub scheme: TPMI_ALG_KEYEDHASH_SCHEME,
    pub details: TPMU_SCHEME_KEYEDHASH,
}
#[test]
fn bindgen_test_layout_TPMT_KEYEDHASH_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_KEYEDHASH_SCHEME>() , 6usize ,
               concat ! ( "Size of: " , stringify ! ( TPMT_KEYEDHASH_SCHEME )
               ));
    assert_eq! (::std::mem::align_of::<TPMT_KEYEDHASH_SCHEME>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMT_KEYEDHASH_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_KEYEDHASH_SCHEME ) ) . scheme as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_KEYEDHASH_SCHEME )
                , "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_KEYEDHASH_SCHEME ) ) . details as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_KEYEDHASH_SCHEME )
                , "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_KEYEDHASH_SCHEME {
    fn clone(&self) -> Self { *self }
}
pub type TPMS_SIG_SCHEME_RSASSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_RSAPSS = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDSA = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_SM2 = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECSCHNORR = TPMS_SCHEME_HASH;
pub type TPMS_SIG_SCHEME_ECDAA = TPMS_SCHEME_ECDAA;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_SIG_SCHEME {
    pub rsassa: __BindgenUnionField<TPMS_SIG_SCHEME_RSASSA>,
    pub rsapss: __BindgenUnionField<TPMS_SIG_SCHEME_RSAPSS>,
    pub ecdsa: __BindgenUnionField<TPMS_SIG_SCHEME_ECDSA>,
    pub ecdaa: __BindgenUnionField<TPMS_SIG_SCHEME_ECDAA>,
    pub sm2: __BindgenUnionField<TPMS_SIG_SCHEME_SM2>,
    pub ecschnorr: __BindgenUnionField<TPMS_SIG_SCHEME_ECSCHNORR>,
    pub hmac: __BindgenUnionField<TPMS_SCHEME_HMAC>,
    pub any: __BindgenUnionField<TPMS_SCHEME_HASH>,
    pub bindgen_union_field: [u16; 2usize],
}
#[test]
fn bindgen_test_layout_TPMU_SIG_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMU_SIG_SCHEME>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMU_SIG_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMU_SIG_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMU_SIG_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . rsassa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( rsassa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . rsapss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( rsapss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . ecdsa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( ecdsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . ecdaa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( ecdaa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . sm2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( sm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . ecschnorr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( ecschnorr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . hmac as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( hmac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIG_SCHEME ) ) . any as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIG_SCHEME ) ,
                "::" , stringify ! ( any ) ));
}
impl Clone for TPMU_SIG_SCHEME {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_SIG_SCHEME {
    pub scheme: TPMI_ALG_SIG_SCHEME,
    pub details: TPMU_SIG_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_SIG_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_SIG_SCHEME>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_SIG_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMT_SIG_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_SIG_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SIG_SCHEME ) ) . scheme as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SIG_SCHEME ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SIG_SCHEME ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SIG_SCHEME ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_SIG_SCHEME {
    fn clone(&self) -> Self { *self }
}
pub type TPMS_ENC_SCHEME_OAEP = TPMS_SCHEME_HASH;
pub type TPMS_ENC_SCHEME_RSAES = TPMS_EMPTY;
pub type TPMS_KEY_SCHEME_ECDH = TPMS_SCHEME_HASH;
pub type TPMS_KEY_SCHEME_ECMQV = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_MGF1 = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF1_SP800_56A = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF2 = TPMS_SCHEME_HASH;
pub type TPMS_SCHEME_KDF1_SP800_108 = TPMS_SCHEME_HASH;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_KDF_SCHEME {
    pub mgf1: __BindgenUnionField<TPMS_SCHEME_MGF1>,
    pub kdf1_sp800_56a: __BindgenUnionField<TPMS_SCHEME_KDF1_SP800_56A>,
    pub kdf1_sp800_108: __BindgenUnionField<TPMS_SCHEME_KDF1_SP800_108>,
    pub bindgen_union_field: u16,
}
#[test]
fn bindgen_test_layout_TPMU_KDF_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMU_KDF_SCHEME>() , 2usize , concat ! (
               "Size of: " , stringify ! ( TPMU_KDF_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMU_KDF_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMU_KDF_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_KDF_SCHEME ) ) . mgf1 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_KDF_SCHEME ) ,
                "::" , stringify ! ( mgf1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_KDF_SCHEME ) ) . kdf1_sp800_56a as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_KDF_SCHEME ) ,
                "::" , stringify ! ( kdf1_sp800_56a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_KDF_SCHEME ) ) . kdf1_sp800_108 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_KDF_SCHEME ) ,
                "::" , stringify ! ( kdf1_sp800_108 ) ));
}
impl Clone for TPMU_KDF_SCHEME {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_KDF_SCHEME {
    pub scheme: TPMI_ALG_KDF,
    pub details: TPMU_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_KDF_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_KDF_SCHEME>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMT_KDF_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMT_KDF_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_KDF_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_KDF_SCHEME ) ) . scheme as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_KDF_SCHEME ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_KDF_SCHEME ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_KDF_SCHEME ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_KDF_SCHEME {
    fn clone(&self) -> Self { *self }
}
pub type TPMI_ALG_ASYM_SCHEME = TPM_ALG_ID;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_ASYM_SCHEME {
    pub ecdh: __BindgenUnionField<TPMS_KEY_SCHEME_ECDH>,
    pub rsassa: __BindgenUnionField<TPMS_SIG_SCHEME_RSASSA>,
    pub rsapss: __BindgenUnionField<TPMS_SIG_SCHEME_RSAPSS>,
    pub ecdsa: __BindgenUnionField<TPMS_SIG_SCHEME_ECDSA>,
    pub ecdaa: __BindgenUnionField<TPMS_SIG_SCHEME_ECDAA>,
    pub sm2: __BindgenUnionField<TPMS_SIG_SCHEME_SM2>,
    pub ecschnorr: __BindgenUnionField<TPMS_SIG_SCHEME_ECSCHNORR>,
    pub rsaes: __BindgenUnionField<TPMS_ENC_SCHEME_RSAES>,
    pub oaep: __BindgenUnionField<TPMS_ENC_SCHEME_OAEP>,
    pub anySig: __BindgenUnionField<TPMS_SCHEME_HASH>,
    pub bindgen_union_field: [u16; 2usize],
}
#[test]
fn bindgen_test_layout_TPMU_ASYM_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMU_ASYM_SCHEME>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMU_ASYM_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMU_ASYM_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMU_ASYM_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . ecdh as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( ecdh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . rsassa as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( rsassa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . rsapss as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( rsapss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . ecdsa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( ecdsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . ecdaa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( ecdaa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . sm2 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( sm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . ecschnorr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( ecschnorr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . rsaes as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( rsaes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . oaep as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( oaep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ASYM_SCHEME ) ) . anySig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ASYM_SCHEME ) ,
                "::" , stringify ! ( anySig ) ));
}
impl Clone for TPMU_ASYM_SCHEME {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_ASYM_SCHEME {
    pub scheme: TPMI_ALG_ASYM_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ASYM_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_ASYM_SCHEME>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_ASYM_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMT_ASYM_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_ASYM_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_ASYM_SCHEME ) ) . scheme as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_ASYM_SCHEME ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_ASYM_SCHEME ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_ASYM_SCHEME ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_ASYM_SCHEME {
    fn clone(&self) -> Self { *self }
}
pub type TPMI_ALG_RSA_SCHEME = TPM_ALG_ID;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_RSA_SCHEME {
    pub scheme: TPMI_ALG_RSA_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_RSA_SCHEME>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_RSA_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMT_RSA_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_RSA_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_RSA_SCHEME ) ) . scheme as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_RSA_SCHEME ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_RSA_SCHEME ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_RSA_SCHEME ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_RSA_SCHEME {
    fn clone(&self) -> Self { *self }
}
pub type TPMI_ALG_RSA_DECRYPT = TPM_ALG_ID;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_RSA_DECRYPT {
    pub scheme: TPMI_ALG_RSA_DECRYPT,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_RSA_DECRYPT() {
    assert_eq!(::std::mem::size_of::<TPMT_RSA_DECRYPT>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_RSA_DECRYPT ) ));
    assert_eq! (::std::mem::align_of::<TPMT_RSA_DECRYPT>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_RSA_DECRYPT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_RSA_DECRYPT ) ) . scheme as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_RSA_DECRYPT ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_RSA_DECRYPT ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_RSA_DECRYPT ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_RSA_DECRYPT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PUBLIC_KEY_RSA {
    pub t: __BindgenUnionField<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 129usize],
}
#[repr(C)]
pub struct TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>() ,
               258usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_PUBLIC_KEY_RSA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC_KEY_RSA() {
    assert_eq!(::std::mem::size_of::<TPM2B_PUBLIC_KEY_RSA>() , 258usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_PUBLIC_KEY_RSA )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_PUBLIC_KEY_RSA>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_PUBLIC_KEY_RSA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC_KEY_RSA ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PUBLIC_KEY_RSA )
                , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC_KEY_RSA ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PUBLIC_KEY_RSA )
                , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_PUBLIC_KEY_RSA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PUBLIC_KEY_RSA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMI_RSA_KEY_BITS = TPM_KEY_BITS;
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PRIVATE_KEY_RSA {
    pub t: __BindgenUnionField<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 65usize],
}
#[repr(C)]
pub struct TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 128usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>() ,
               130usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_PRIVATE_KEY_RSA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_KEY_RSA() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE_KEY_RSA>() , 130usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_PRIVATE_KEY_RSA )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE_KEY_RSA>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_PRIVATE_KEY_RSA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_KEY_RSA ) ) . t as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PRIVATE_KEY_RSA )
                , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_KEY_RSA ) ) . b as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PRIVATE_KEY_RSA )
                , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_PRIVATE_KEY_RSA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PRIVATE_KEY_RSA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_ECC_PARAMETER {
    pub t: __BindgenUnionField<TPM2B_ECC_PARAMETER__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 25usize],
}
#[repr(C)]
pub struct TPM2B_ECC_PARAMETER__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_PARAMETER__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_ECC_PARAMETER__bindgen_ty_1>() ,
               50usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_ECC_PARAMETER__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_ECC_PARAMETER__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_ECC_PARAMETER__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_PARAMETER__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ECC_PARAMETER__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_PARAMETER__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ECC_PARAMETER__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_ECC_PARAMETER__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_PARAMETER() {
    assert_eq!(::std::mem::size_of::<TPM2B_ECC_PARAMETER>() , 50usize , concat
               ! ( "Size of: " , stringify ! ( TPM2B_ECC_PARAMETER ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ECC_PARAMETER>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_ECC_PARAMETER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_PARAMETER ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ECC_PARAMETER ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_PARAMETER ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ECC_PARAMETER ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_ECC_PARAMETER {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ECC_POINT {
    pub x: TPM2B_ECC_PARAMETER,
    pub y: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_POINT() {
    assert_eq!(::std::mem::size_of::<TPMS_ECC_POINT>() , 100usize , concat ! (
               "Size of: " , stringify ! ( TPMS_ECC_POINT ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ECC_POINT>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_ECC_POINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_POINT ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_POINT ) , "::"
                , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_POINT ) ) . y as * const _ as
                usize } , 50usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_POINT ) , "::"
                , stringify ! ( y ) ));
}
impl Clone for TPMS_ECC_POINT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_ECC_POINT {
    pub t: __BindgenUnionField<TPM2B_ECC_POINT__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 51usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_ECC_POINT__bindgen_ty_1 {
    pub size: UINT16,
    pub point: TPMS_ECC_POINT,
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_POINT__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_ECC_POINT__bindgen_ty_1>() ,
               102usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_ECC_POINT__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ECC_POINT__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_ECC_POINT__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_POINT__bindgen_ty_1 ) ) . size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ECC_POINT__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_POINT__bindgen_ty_1 ) ) . point
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ECC_POINT__bindgen_ty_1 ) , "::" , stringify ! ( point )
                ));
}
impl Clone for TPM2B_ECC_POINT__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_TPM2B_ECC_POINT() {
    assert_eq!(::std::mem::size_of::<TPM2B_ECC_POINT>() , 102usize , concat !
               ( "Size of: " , stringify ! ( TPM2B_ECC_POINT ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ECC_POINT>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPM2B_ECC_POINT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_POINT ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ECC_POINT ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ECC_POINT ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ECC_POINT ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_ECC_POINT {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_ECC_POINT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMI_ALG_ECC_SCHEME = TPM_ALG_ID;
pub type TPMI_ECC_CURVE = TPM_ECC_CURVE;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_ECC_SCHEME {
    pub scheme: TPMI_ALG_ECC_SCHEME,
    pub details: TPMU_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMT_ECC_SCHEME() {
    assert_eq!(::std::mem::size_of::<TPMT_ECC_SCHEME>() , 6usize , concat ! (
               "Size of: " , stringify ! ( TPMT_ECC_SCHEME ) ));
    assert_eq! (::std::mem::align_of::<TPMT_ECC_SCHEME>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMT_ECC_SCHEME ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_ECC_SCHEME ) ) . scheme as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_ECC_SCHEME ) ,
                "::" , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_ECC_SCHEME ) ) . details as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_ECC_SCHEME ) ,
                "::" , stringify ! ( details ) ));
}
impl Clone for TPMT_ECC_SCHEME {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ALGORITHM_DETAIL_ECC {
    pub curveID: TPM_ECC_CURVE,
    pub keySize: UINT16,
    pub kdf: TPMT_KDF_SCHEME,
    pub sign: TPMT_ECC_SCHEME,
    pub p: TPM2B_ECC_PARAMETER,
    pub a: TPM2B_ECC_PARAMETER,
    pub b: TPM2B_ECC_PARAMETER,
    pub gX: TPM2B_ECC_PARAMETER,
    pub gY: TPM2B_ECC_PARAMETER,
    pub n: TPM2B_ECC_PARAMETER,
    pub h: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_ALGORITHM_DETAIL_ECC() {
    assert_eq!(::std::mem::size_of::<TPMS_ALGORITHM_DETAIL_ECC>() , 364usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMS_ALGORITHM_DETAIL_ECC ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ALGORITHM_DETAIL_ECC>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_ALGORITHM_DETAIL_ECC )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . curveID
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( curveID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . keySize
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( keySize )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . kdf as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( kdf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . sign as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( sign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . p as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . a as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( a ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . b as *
                const _ as usize } , 114usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . gX as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( gX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . gY as *
                const _ as usize } , 214usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( gY ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . n as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ALGORITHM_DETAIL_ECC ) ) . h as *
                const _ as usize } , 314usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_ALGORITHM_DETAIL_ECC ) , "::" , stringify ! ( h ) ));
}
impl Clone for TPMS_ALGORITHM_DETAIL_ECC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_SIGNATURE_RSA {
    pub hash: TPMI_ALG_HASH,
    pub sig: TPM2B_PUBLIC_KEY_RSA,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_RSA() {
    assert_eq!(::std::mem::size_of::<TPMS_SIGNATURE_RSA>() , 260usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_SIGNATURE_RSA ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SIGNATURE_RSA>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_SIGNATURE_RSA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SIGNATURE_RSA ) ) . hash as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SIGNATURE_RSA ) ,
                "::" , stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SIGNATURE_RSA ) ) . sig as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SIGNATURE_RSA ) ,
                "::" , stringify ! ( sig ) ));
}
impl Clone for TPMS_SIGNATURE_RSA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_SIGNATURE_RSA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMS_SIGNATURE_RSASSA = TPMS_SIGNATURE_RSA;
pub type TPMS_SIGNATURE_RSAPSS = TPMS_SIGNATURE_RSA;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_SIGNATURE_ECC {
    pub hash: TPMI_ALG_HASH,
    pub signatureR: TPM2B_ECC_PARAMETER,
    pub signatureS: TPM2B_ECC_PARAMETER,
}
#[test]
fn bindgen_test_layout_TPMS_SIGNATURE_ECC() {
    assert_eq!(::std::mem::size_of::<TPMS_SIGNATURE_ECC>() , 102usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_SIGNATURE_ECC ) ));
    assert_eq! (::std::mem::align_of::<TPMS_SIGNATURE_ECC>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_SIGNATURE_ECC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SIGNATURE_ECC ) ) . hash as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SIGNATURE_ECC ) ,
                "::" , stringify ! ( hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SIGNATURE_ECC ) ) . signatureR as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SIGNATURE_ECC ) ,
                "::" , stringify ! ( signatureR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_SIGNATURE_ECC ) ) . signatureS as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_SIGNATURE_ECC ) ,
                "::" , stringify ! ( signatureS ) ));
}
impl Clone for TPMS_SIGNATURE_ECC {
    fn clone(&self) -> Self { *self }
}
pub type TPMS_SIGNATURE_ECDSA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECDAA = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_SM2 = TPMS_SIGNATURE_ECC;
pub type TPMS_SIGNATURE_ECSCHNORR = TPMS_SIGNATURE_ECC;
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_SIGNATURE {
    pub rsassa: __BindgenUnionField<TPMS_SIGNATURE_RSASSA>,
    pub rsapss: __BindgenUnionField<TPMS_SIGNATURE_RSAPSS>,
    pub ecdsa: __BindgenUnionField<TPMS_SIGNATURE_ECDSA>,
    pub ecdaa: __BindgenUnionField<TPMS_SIGNATURE_ECDAA>,
    pub sm2: __BindgenUnionField<TPMS_SIGNATURE_SM2>,
    pub ecschnorr: __BindgenUnionField<TPMS_SIGNATURE_ECSCHNORR>,
    pub hmac: __BindgenUnionField<TPMT_HA>,
    pub any: __BindgenUnionField<TPMS_SCHEME_HASH>,
    pub bindgen_union_field: [u16; 130usize],
}
#[test]
fn bindgen_test_layout_TPMU_SIGNATURE() {
    assert_eq!(::std::mem::size_of::<TPMU_SIGNATURE>() , 260usize , concat ! (
               "Size of: " , stringify ! ( TPMU_SIGNATURE ) ));
    assert_eq! (::std::mem::align_of::<TPMU_SIGNATURE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_SIGNATURE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . rsassa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( rsassa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . rsapss as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( rsapss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . ecdsa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( ecdsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . ecdaa as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( ecdaa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . sm2 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( sm2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . ecschnorr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( ecschnorr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . hmac as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( hmac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SIGNATURE ) ) . any as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_SIGNATURE ) , "::"
                , stringify ! ( any ) ));
}
impl Clone for TPMU_SIGNATURE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_SIGNATURE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_SIGNATURE {
    pub sigAlg: TPMI_ALG_SIG_SCHEME,
    pub signature: TPMU_SIGNATURE,
}
#[test]
fn bindgen_test_layout_TPMT_SIGNATURE() {
    assert_eq!(::std::mem::size_of::<TPMT_SIGNATURE>() , 262usize , concat ! (
               "Size of: " , stringify ! ( TPMT_SIGNATURE ) ));
    assert_eq! (::std::mem::align_of::<TPMT_SIGNATURE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_SIGNATURE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SIGNATURE ) ) . sigAlg as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SIGNATURE ) , "::"
                , stringify ! ( sigAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SIGNATURE ) ) . signature as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SIGNATURE ) , "::"
                , stringify ! ( signature ) ));
}
impl Clone for TPMT_SIGNATURE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_SIGNATURE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_ENCRYPTED_SECRET {
    pub ecc: __BindgenUnionField<[BYTE; 100usize]>,
    pub rsa: __BindgenUnionField<[BYTE; 256usize]>,
    pub symmetric: __BindgenUnionField<[BYTE; 66usize]>,
    pub keyedHash: __BindgenUnionField<[BYTE; 66usize]>,
    pub bindgen_union_field: [u8; 256usize],
}
#[test]
fn bindgen_test_layout_TPMU_ENCRYPTED_SECRET() {
    assert_eq!(::std::mem::size_of::<TPMU_ENCRYPTED_SECRET>() , 256usize ,
               concat ! ( "Size of: " , stringify ! ( TPMU_ENCRYPTED_SECRET )
               ));
    assert_eq! (::std::mem::align_of::<TPMU_ENCRYPTED_SECRET>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMU_ENCRYPTED_SECRET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ENCRYPTED_SECRET ) ) . ecc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ENCRYPTED_SECRET )
                , "::" , stringify ! ( ecc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ENCRYPTED_SECRET ) ) . rsa as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ENCRYPTED_SECRET )
                , "::" , stringify ! ( rsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ENCRYPTED_SECRET ) ) . symmetric as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ENCRYPTED_SECRET )
                , "::" , stringify ! ( symmetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_ENCRYPTED_SECRET ) ) . keyedHash as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_ENCRYPTED_SECRET )
                , "::" , stringify ! ( keyedHash ) ));
}
impl Clone for TPMU_ENCRYPTED_SECRET {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_ENCRYPTED_SECRET {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_ENCRYPTED_SECRET {
    pub t: __BindgenUnionField<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 129usize],
}
#[repr(C)]
pub struct TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 {
    pub size: UINT16,
    pub secret: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ENCRYPTED_SECRET__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>() ,
               258usize , concat ! (
               "Size of: " , stringify ! (
               TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ENCRYPTED_SECRET__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) )
                . size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) )
                . secret as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 ) , "::" , stringify ! (
                secret ) ));
}
impl Default for TPM2B_ENCRYPTED_SECRET__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_ENCRYPTED_SECRET() {
    assert_eq!(::std::mem::size_of::<TPM2B_ENCRYPTED_SECRET>() , 258usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_ENCRYPTED_SECRET )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_ENCRYPTED_SECRET>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_ENCRYPTED_SECRET ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ENCRYPTED_SECRET ) ) . t as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ENCRYPTED_SECRET
                ) , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ENCRYPTED_SECRET ) ) . b as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ENCRYPTED_SECRET
                ) , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_ENCRYPTED_SECRET {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_ENCRYPTED_SECRET {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TPMI_ALG_PUBLIC = TPM_ALG_ID;
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_PUBLIC_ID {
    pub keyedHash: __BindgenUnionField<TPM2B_DIGEST>,
    pub sym: __BindgenUnionField<TPM2B_DIGEST>,
    pub rsa: __BindgenUnionField<TPM2B_PUBLIC_KEY_RSA>,
    pub ecc: __BindgenUnionField<TPMS_ECC_POINT>,
    pub bindgen_union_field: [u16; 129usize],
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_ID() {
    assert_eq!(::std::mem::size_of::<TPMU_PUBLIC_ID>() , 258usize , concat ! (
               "Size of: " , stringify ! ( TPMU_PUBLIC_ID ) ));
    assert_eq! (::std::mem::align_of::<TPMU_PUBLIC_ID>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMU_PUBLIC_ID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_ID ) ) . keyedHash as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_ID ) , "::"
                , stringify ! ( keyedHash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_ID ) ) . sym as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_ID ) , "::"
                , stringify ! ( sym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_ID ) ) . rsa as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_ID ) , "::"
                , stringify ! ( rsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_ID ) ) . ecc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_ID ) , "::"
                , stringify ! ( ecc ) ));
}
impl Clone for TPMU_PUBLIC_ID {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_PUBLIC_ID {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_KEYEDHASH_PARMS {
    pub scheme: TPMT_KEYEDHASH_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_KEYEDHASH_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMS_KEYEDHASH_PARMS>() , 6usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_KEYEDHASH_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMS_KEYEDHASH_PARMS>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMS_KEYEDHASH_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_KEYEDHASH_PARMS ) ) . scheme as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_KEYEDHASH_PARMS )
                , "::" , stringify ! ( scheme ) ));
}
impl Clone for TPMS_KEYEDHASH_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ASYM_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ASYM_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ASYM_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMS_ASYM_PARMS>() , 12usize , concat ! (
               "Size of: " , stringify ! ( TPMS_ASYM_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ASYM_PARMS>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPMS_ASYM_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ASYM_PARMS ) ) . symmetric as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ASYM_PARMS ) ,
                "::" , stringify ! ( symmetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ASYM_PARMS ) ) . scheme as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ASYM_PARMS ) ,
                "::" , stringify ! ( scheme ) ));
}
impl Clone for TPMS_ASYM_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_RSA_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_RSA_SCHEME,
    pub keyBits: TPMI_RSA_KEY_BITS,
    pub exponent: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_RSA_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMS_RSA_PARMS>() , 20usize , concat ! (
               "Size of: " , stringify ! ( TPMS_RSA_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMS_RSA_PARMS>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_RSA_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_RSA_PARMS ) ) . symmetric as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_RSA_PARMS ) , "::"
                , stringify ! ( symmetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_RSA_PARMS ) ) . scheme as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_RSA_PARMS ) , "::"
                , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_RSA_PARMS ) ) . keyBits as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_RSA_PARMS ) , "::"
                , stringify ! ( keyBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_RSA_PARMS ) ) . exponent as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_RSA_PARMS ) , "::"
                , stringify ! ( exponent ) ));
}
impl Clone for TPMS_RSA_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_ECC_PARMS {
    pub symmetric: TPMT_SYM_DEF_OBJECT,
    pub scheme: TPMT_ECC_SCHEME,
    pub curveID: TPMI_ECC_CURVE,
    pub kdf: TPMT_KDF_SCHEME,
}
#[test]
fn bindgen_test_layout_TPMS_ECC_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMS_ECC_PARMS>() , 18usize , concat ! (
               "Size of: " , stringify ! ( TPMS_ECC_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMS_ECC_PARMS>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_ECC_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_PARMS ) ) . symmetric as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_PARMS ) , "::"
                , stringify ! ( symmetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_PARMS ) ) . scheme as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_PARMS ) , "::"
                , stringify ! ( scheme ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_PARMS ) ) . curveID as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_PARMS ) , "::"
                , stringify ! ( curveID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_ECC_PARMS ) ) . kdf as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_ECC_PARMS ) , "::"
                , stringify ! ( kdf ) ));
}
impl Clone for TPMS_ECC_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMU_PUBLIC_PARMS {
    pub keyedHashDetail: __BindgenUnionField<TPMS_KEYEDHASH_PARMS>,
    pub symDetail: __BindgenUnionField<TPMS_SYMCIPHER_PARMS>,
    pub rsaDetail: __BindgenUnionField<TPMS_RSA_PARMS>,
    pub eccDetail: __BindgenUnionField<TPMS_ECC_PARMS>,
    pub asymDetail: __BindgenUnionField<TPMS_ASYM_PARMS>,
    pub bindgen_union_field: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_TPMU_PUBLIC_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMU_PUBLIC_PARMS>() , 20usize , concat !
               ( "Size of: " , stringify ! ( TPMU_PUBLIC_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMU_PUBLIC_PARMS>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMU_PUBLIC_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_PARMS ) ) . keyedHashDetail
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_PARMS ) ,
                "::" , stringify ! ( keyedHashDetail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_PARMS ) ) . symDetail as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_PARMS ) ,
                "::" , stringify ! ( symDetail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_PARMS ) ) . rsaDetail as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_PARMS ) ,
                "::" , stringify ! ( rsaDetail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_PARMS ) ) . eccDetail as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_PARMS ) ,
                "::" , stringify ! ( eccDetail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_PUBLIC_PARMS ) ) . asymDetail as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMU_PUBLIC_PARMS ) ,
                "::" , stringify ! ( asymDetail ) ));
}
impl Clone for TPMU_PUBLIC_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMT_PUBLIC_PARMS {
    pub type_: TPMI_ALG_PUBLIC,
    pub parameters: TPMU_PUBLIC_PARMS,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC_PARMS() {
    assert_eq!(::std::mem::size_of::<TPMT_PUBLIC_PARMS>() , 24usize , concat !
               ( "Size of: " , stringify ! ( TPMT_PUBLIC_PARMS ) ));
    assert_eq! (::std::mem::align_of::<TPMT_PUBLIC_PARMS>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMT_PUBLIC_PARMS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC_PARMS ) ) . type_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC_PARMS ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC_PARMS ) ) . parameters as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC_PARMS ) ,
                "::" , stringify ! ( parameters ) ));
}
impl Clone for TPMT_PUBLIC_PARMS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_PUBLIC {
    pub type_: TPMI_ALG_PUBLIC,
    pub nameAlg: TPMI_ALG_HASH,
    pub objectAttributes: TPMA_OBJECT,
    pub authPolicy: TPM2B_DIGEST,
    pub parameters: TPMU_PUBLIC_PARMS,
    pub unique: TPMU_PUBLIC_ID,
}
#[test]
fn bindgen_test_layout_TPMT_PUBLIC() {
    assert_eq!(::std::mem::size_of::<TPMT_PUBLIC>() , 356usize , concat ! (
               "Size of: " , stringify ! ( TPMT_PUBLIC ) ));
    assert_eq! (::std::mem::align_of::<TPMT_PUBLIC>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . nameAlg as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( nameAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . objectAttributes as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( objectAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . authPolicy as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( authPolicy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . parameters as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( parameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_PUBLIC ) ) . unique as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_PUBLIC ) , "::" ,
                stringify ! ( unique ) ));
}
impl Clone for TPMT_PUBLIC {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_PUBLIC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PUBLIC {
    pub t: __BindgenUnionField<TPM2B_PUBLIC__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u32; 90usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PUBLIC__bindgen_ty_1 {
    pub size: UINT16,
    pub publicArea: TPMT_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_PUBLIC__bindgen_ty_1>() , 360usize
               , concat ! (
               "Size of: " , stringify ! ( TPM2B_PUBLIC__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PUBLIC__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM2B_PUBLIC__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC__bindgen_ty_1 ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PUBLIC__bindgen_ty_1 ) , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC__bindgen_ty_1 ) ) .
                publicArea as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PUBLIC__bindgen_ty_1 ) , "::" , stringify ! ( publicArea
                ) ));
}
impl Clone for TPM2B_PUBLIC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PUBLIC__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_PUBLIC() {
    assert_eq!(::std::mem::size_of::<TPM2B_PUBLIC>() , 360usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_PUBLIC ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PUBLIC>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PUBLIC ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PUBLIC ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PUBLIC ) , "::" ,
                stringify ! ( b ) ));
}
impl Clone for TPM2B_PUBLIC {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PUBLIC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC {
    pub t: __BindgenUnionField<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 321usize],
}
#[repr(C)]
pub struct TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 640usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>()
               , 642usize , concat ! (
               "Size of: " , stringify ! (
               TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 )
                ) . size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 )
                ) . buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Default for TPM2B_PRIVATE_VENDOR_SPECIFIC__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE_VENDOR_SPECIFIC() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>() ,
               642usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_PRIVATE_VENDOR_SPECIFIC ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE_VENDOR_SPECIFIC>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_PRIVATE_VENDOR_SPECIFIC
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_VENDOR_SPECIFIC ) ) . t as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_VENDOR_SPECIFIC ) , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE_VENDOR_SPECIFIC ) ) . b as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE_VENDOR_SPECIFIC ) , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PRIVATE_VENDOR_SPECIFIC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMU_SENSITIVE_COMPOSITE {
    pub rsa: __BindgenUnionField<TPM2B_PRIVATE_KEY_RSA>,
    pub ecc: __BindgenUnionField<TPM2B_ECC_PARAMETER>,
    pub bits: __BindgenUnionField<TPM2B_SENSITIVE_DATA>,
    pub sym: __BindgenUnionField<TPM2B_SYM_KEY>,
    pub any: __BindgenUnionField<TPM2B_PRIVATE_VENDOR_SPECIFIC>,
    pub bindgen_union_field: [u16; 321usize],
}
#[test]
fn bindgen_test_layout_TPMU_SENSITIVE_COMPOSITE() {
    assert_eq!(::std::mem::size_of::<TPMU_SENSITIVE_COMPOSITE>() , 642usize ,
               concat ! (
               "Size of: " , stringify ! ( TPMU_SENSITIVE_COMPOSITE ) ));
    assert_eq! (::std::mem::align_of::<TPMU_SENSITIVE_COMPOSITE>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMU_SENSITIVE_COMPOSITE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SENSITIVE_COMPOSITE ) ) . rsa as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMU_SENSITIVE_COMPOSITE ) , "::" , stringify ! ( rsa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SENSITIVE_COMPOSITE ) ) . ecc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMU_SENSITIVE_COMPOSITE ) , "::" , stringify ! ( ecc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SENSITIVE_COMPOSITE ) ) . bits as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMU_SENSITIVE_COMPOSITE ) , "::" , stringify ! ( bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SENSITIVE_COMPOSITE ) ) . sym as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMU_SENSITIVE_COMPOSITE ) , "::" , stringify ! ( sym ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMU_SENSITIVE_COMPOSITE ) ) . any as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMU_SENSITIVE_COMPOSITE ) , "::" , stringify ! ( any ) ));
}
impl Clone for TPMU_SENSITIVE_COMPOSITE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMU_SENSITIVE_COMPOSITE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMT_SENSITIVE {
    pub sensitiveType: TPMI_ALG_PUBLIC,
    pub authValue: TPM2B_AUTH,
    pub seedValue: TPM2B_DIGEST,
    pub sensitive: TPMU_SENSITIVE_COMPOSITE,
}
#[test]
fn bindgen_test_layout_TPMT_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<TPMT_SENSITIVE>() , 776usize , concat ! (
               "Size of: " , stringify ! ( TPMT_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<TPMT_SENSITIVE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPMT_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SENSITIVE ) ) . sensitiveType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SENSITIVE ) , "::"
                , stringify ! ( sensitiveType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SENSITIVE ) ) . authValue as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SENSITIVE ) , "::"
                , stringify ! ( authValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SENSITIVE ) ) . seedValue as * const
                _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SENSITIVE ) , "::"
                , stringify ! ( seedValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMT_SENSITIVE ) ) . sensitive as * const
                _ as usize } , 134usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMT_SENSITIVE ) , "::"
                , stringify ! ( sensitive ) ));
}
impl Clone for TPMT_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMT_SENSITIVE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_SENSITIVE {
    pub t: __BindgenUnionField<TPM2B_SENSITIVE__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 389usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_SENSITIVE__bindgen_ty_1 {
    pub size: UINT16,
    pub sensitiveArea: TPMT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE__bindgen_ty_1>() ,
               778usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_SENSITIVE__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_SENSITIVE__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE__bindgen_ty_1 ) ) . size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE__bindgen_ty_1 ) ) .
                sensitiveArea as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_SENSITIVE__bindgen_ty_1 ) , "::" , stringify ! (
                sensitiveArea ) ));
}
impl Clone for TPM2B_SENSITIVE__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_SENSITIVE__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<TPM2B_SENSITIVE>() , 778usize , concat !
               ( "Size of: " , stringify ! ( TPM2B_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_SENSITIVE>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPM2B_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_SENSITIVE ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_SENSITIVE ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_SENSITIVE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _PRIVATE {
    pub integrityOuter: TPM2B_DIGEST,
    pub integrityInner: TPM2B_DIGEST,
    pub sensitive: TPM2B_SENSITIVE,
}
#[test]
fn bindgen_test_layout__PRIVATE() {
    assert_eq!(::std::mem::size_of::<_PRIVATE>() , 910usize , concat ! (
               "Size of: " , stringify ! ( _PRIVATE ) ));
    assert_eq! (::std::mem::align_of::<_PRIVATE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _PRIVATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PRIVATE ) ) . integrityOuter as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _PRIVATE ) , "::" ,
                stringify ! ( integrityOuter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PRIVATE ) ) . integrityInner as * const
                _ as usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( _PRIVATE ) , "::" ,
                stringify ! ( integrityInner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _PRIVATE ) ) . sensitive as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( _PRIVATE ) , "::" ,
                stringify ! ( sensitive ) ));
}
impl Clone for _PRIVATE {
    fn clone(&self) -> Self { *self }
}
impl Default for _PRIVATE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_PRIVATE {
    pub t: __BindgenUnionField<TPM2B_PRIVATE__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 456usize],
}
#[repr(C)]
pub struct TPM2B_PRIVATE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 910usize],
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE__bindgen_ty_1>() , 912usize
               , concat ! (
               "Size of: " , stringify ! ( TPM2B_PRIVATE__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE__bindgen_ty_1>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM2B_PRIVATE__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE__bindgen_ty_1 ) ) . size as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE__bindgen_ty_1 ) ) . buffer
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_PRIVATE__bindgen_ty_1 ) , "::" , stringify ! ( buffer )
                ));
}
impl Default for TPM2B_PRIVATE__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_PRIVATE() {
    assert_eq!(::std::mem::size_of::<TPM2B_PRIVATE>() , 912usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_PRIVATE ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_PRIVATE>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_PRIVATE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PRIVATE ) , "::"
                , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_PRIVATE ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_PRIVATE ) , "::"
                , stringify ! ( b ) ));
}
impl Clone for TPM2B_PRIVATE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_PRIVATE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct _ID_OBJECT {
    pub integrityHMAC: TPM2B_DIGEST,
    pub encIdentity: TPM2B_DIGEST,
}
#[test]
fn bindgen_test_layout__ID_OBJECT() {
    assert_eq!(::std::mem::size_of::<_ID_OBJECT>() , 132usize , concat ! (
               "Size of: " , stringify ! ( _ID_OBJECT ) ));
    assert_eq! (::std::mem::align_of::<_ID_OBJECT>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( _ID_OBJECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ID_OBJECT ) ) . integrityHMAC as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _ID_OBJECT ) , "::" ,
                stringify ! ( integrityHMAC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _ID_OBJECT ) ) . encIdentity as * const _
                as usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( _ID_OBJECT ) , "::" ,
                stringify ! ( encIdentity ) ));
}
impl Clone for _ID_OBJECT {
    fn clone(&self) -> Self { *self }
}
impl Default for _ID_OBJECT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_ID_OBJECT {
    pub t: __BindgenUnionField<TPM2B_ID_OBJECT__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 67usize],
}
#[repr(C)]
pub struct TPM2B_ID_OBJECT__bindgen_ty_1 {
    pub size: UINT16,
    pub credential: [BYTE; 132usize],
}
#[test]
fn bindgen_test_layout_TPM2B_ID_OBJECT__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_ID_OBJECT__bindgen_ty_1>() ,
               134usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_ID_OBJECT__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ID_OBJECT__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_ID_OBJECT__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ID_OBJECT__bindgen_ty_1 ) ) . size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ID_OBJECT__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ID_OBJECT__bindgen_ty_1 ) ) .
                credential as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_ID_OBJECT__bindgen_ty_1 ) , "::" , stringify ! (
                credential ) ));
}
impl Default for TPM2B_ID_OBJECT__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_ID_OBJECT() {
    assert_eq!(::std::mem::size_of::<TPM2B_ID_OBJECT>() , 134usize , concat !
               ( "Size of: " , stringify ! ( TPM2B_ID_OBJECT ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_ID_OBJECT>() , 2usize , concat !
                ( "Alignment of " , stringify ! ( TPM2B_ID_OBJECT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ID_OBJECT ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ID_OBJECT ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_ID_OBJECT ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_ID_OBJECT ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_ID_OBJECT {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_ID_OBJECT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM_NV_INDEX {
    pub __bindgen_anon_1: __BindgenUnionField<TPM_NV_INDEX__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM_NV_INDEX__bindgen_ty_1 {
    pub _bitfield_1: u32,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPM_NV_INDEX__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM_NV_INDEX__bindgen_ty_1>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM_NV_INDEX__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM_NV_INDEX__bindgen_ty_1>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM_NV_INDEX__bindgen_ty_1 )
                ));
}
impl Clone for TPM_NV_INDEX__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPM_NV_INDEX__bindgen_ty_1 {
    #[inline]
    pub fn index(&self) -> ::std::os::raw::c_uint {
        let mask = 16777215usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_index(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16777215usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn RH_NV(&self) -> ::std::os::raw::c_uint {
        let mask = 4278190080usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_RH_NV(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4278190080usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(index: ::std::os::raw::c_uint,
                          RH_NV: ::std::os::raw::c_uint) -> u32 {
        ({
             ({ 0 } |
                  ((index as u32 as u32) << 0usize) & (16777215usize as u32))
         } | ((RH_NV as u32 as u32) << 24usize) & (4278190080usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPM_NV_INDEX() {
    assert_eq!(::std::mem::size_of::<TPM_NV_INDEX>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPM_NV_INDEX ) ));
    assert_eq! (::std::mem::align_of::<TPM_NV_INDEX>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPM_NV_INDEX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM_NV_INDEX ) ) . val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM_NV_INDEX ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPM_NV_INDEX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMS_NV_PIN_COUNTER_PARAMETERS {
    pub pinCount: UINT32,
    pub pinLimit: UINT32,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PIN_COUNTER_PARAMETERS() {
    assert_eq!(::std::mem::size_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( TPMS_NV_PIN_COUNTER_PARAMETERS )
               ));
    assert_eq! (::std::mem::align_of::<TPMS_NV_PIN_COUNTER_PARAMETERS>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_NV_PIN_COUNTER_PARAMETERS
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PIN_COUNTER_PARAMETERS ) ) .
                pinCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_NV_PIN_COUNTER_PARAMETERS ) , "::" , stringify ! (
                pinCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PIN_COUNTER_PARAMETERS ) ) .
                pinLimit as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPMS_NV_PIN_COUNTER_PARAMETERS ) , "::" , stringify ! (
                pinLimit ) ));
}
impl Clone for TPMS_NV_PIN_COUNTER_PARAMETERS {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_NV {
    pub __bindgen_anon_1: __BindgenUnionField<TPMA_NV__bindgen_ty_1>,
    pub val: __BindgenUnionField<UINT32>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPMA_NV__bindgen_ty_1 {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_TPMA_NV__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPMA_NV__bindgen_ty_1>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( TPMA_NV__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPMA_NV__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPMA_NV__bindgen_ty_1 ) ));
}
impl Clone for TPMA_NV__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl TPMA_NV__bindgen_ty_1 {
    #[inline]
    pub fn TPMA_NV_PPWRITE(&self) -> ::std::os::raw::c_uint {
        let mask = 1usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_PPWRITE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_OWNERWRITE(&self) -> ::std::os::raw::c_uint {
        let mask = 2usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_OWNERWRITE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_AUTHWRITE(&self) -> ::std::os::raw::c_uint {
        let mask = 4usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_AUTHWRITE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_POLICYWRITE(&self) -> ::std::os::raw::c_uint {
        let mask = 8usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_POLICYWRITE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPM_NT(&self) -> ::std::os::raw::c_uint {
        let mask = 240usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPM_NT(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 240usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved1(&self) -> ::std::os::raw::c_uint {
        let mask = 768usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 768usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_POLICY_DELETE(&self) -> ::std::os::raw::c_uint {
        let mask = 1024usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_POLICY_DELETE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 1024usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_WRITELOCKED(&self) -> ::std::os::raw::c_uint {
        let mask = 2048usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_WRITELOCKED(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2048usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_WRITEALL(&self) -> ::std::os::raw::c_uint {
        let mask = 4096usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_WRITEALL(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 4096usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_WRITEDEFINE(&self) -> ::std::os::raw::c_uint {
        let mask = 8192usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_WRITEDEFINE(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 8192usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_WRITE_STCLEAR(&self) -> ::std::os::raw::c_uint {
        let mask = 16384usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_WRITE_STCLEAR(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 16384usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_GLOBALLOCK(&self) -> ::std::os::raw::c_uint {
        let mask = 32768usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_GLOBALLOCK(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32768usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_PPREAD(&self) -> ::std::os::raw::c_uint {
        let mask = 65536usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_PPREAD(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 65536usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_OWNERREAD(&self) -> ::std::os::raw::c_uint {
        let mask = 131072usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_OWNERREAD(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 131072usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_AUTHREAD(&self) -> ::std::os::raw::c_uint {
        let mask = 262144usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_AUTHREAD(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 262144usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_POLICYREAD(&self) -> ::std::os::raw::c_uint {
        let mask = 524288usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_POLICYREAD(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 524288usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn reserved2(&self) -> ::std::os::raw::c_uint {
        let mask = 32505856usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 32505856usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_NO_DA(&self) -> ::std::os::raw::c_uint {
        let mask = 33554432usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_NO_DA(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 33554432usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_ORDERLY(&self) -> ::std::os::raw::c_uint {
        let mask = 67108864usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_ORDERLY(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 67108864usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_CLEAR_STCLEAR(&self) -> ::std::os::raw::c_uint {
        let mask = 134217728usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 27usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_CLEAR_STCLEAR(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 134217728usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 27usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_READLOCKED(&self) -> ::std::os::raw::c_uint {
        let mask = 268435456usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_READLOCKED(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 268435456usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_WRITTEN(&self) -> ::std::os::raw::c_uint {
        let mask = 536870912usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 29usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_WRITTEN(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 536870912usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 29usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_PLATFORMCREATE(&self) -> ::std::os::raw::c_uint {
        let mask = 1073741824usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 30usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_PLATFORMCREATE(&mut self,
                                      val: ::std::os::raw::c_uint) {
        let mask = 1073741824usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 30usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn TPMA_NV_READ_STCLEAR(&self) -> ::std::os::raw::c_uint {
        let mask = 2147483648usize as u32;
        let unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        let val = (unit_field_val & mask) >> 31usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_TPMA_NV_READ_STCLEAR(&mut self, val: ::std::os::raw::c_uint) {
        let mask = 2147483648usize as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 =
            unsafe { ::std::mem::transmute(self._bitfield_1) };
        unit_field_val &= !mask;
        unit_field_val |= (val << 31usize) & mask;
        self._bitfield_1 = unsafe { ::std::mem::transmute(unit_field_val) };
    }
    #[inline]
    pub fn new_bitfield_1(TPMA_NV_PPWRITE: ::std::os::raw::c_uint,
                          TPMA_NV_OWNERWRITE: ::std::os::raw::c_uint,
                          TPMA_NV_AUTHWRITE: ::std::os::raw::c_uint,
                          TPMA_NV_POLICYWRITE: ::std::os::raw::c_uint,
                          TPM_NT: ::std::os::raw::c_uint,
                          reserved1: ::std::os::raw::c_uint,
                          TPMA_NV_POLICY_DELETE: ::std::os::raw::c_uint,
                          TPMA_NV_WRITELOCKED: ::std::os::raw::c_uint,
                          TPMA_NV_WRITEALL: ::std::os::raw::c_uint,
                          TPMA_NV_WRITEDEFINE: ::std::os::raw::c_uint,
                          TPMA_NV_WRITE_STCLEAR: ::std::os::raw::c_uint,
                          TPMA_NV_GLOBALLOCK: ::std::os::raw::c_uint,
                          TPMA_NV_PPREAD: ::std::os::raw::c_uint,
                          TPMA_NV_OWNERREAD: ::std::os::raw::c_uint,
                          TPMA_NV_AUTHREAD: ::std::os::raw::c_uint,
                          TPMA_NV_POLICYREAD: ::std::os::raw::c_uint,
                          reserved2: ::std::os::raw::c_uint,
                          TPMA_NV_NO_DA: ::std::os::raw::c_uint,
                          TPMA_NV_ORDERLY: ::std::os::raw::c_uint,
                          TPMA_NV_CLEAR_STCLEAR: ::std::os::raw::c_uint,
                          TPMA_NV_READLOCKED: ::std::os::raw::c_uint,
                          TPMA_NV_WRITTEN: ::std::os::raw::c_uint,
                          TPMA_NV_PLATFORMCREATE: ::std::os::raw::c_uint,
                          TPMA_NV_READ_STCLEAR: ::std::os::raw::c_uint)
     -> u32 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({
                                                     ({
                                                          ({
                                                               ({
                                                                    ({
                                                                         ({
                                                                              ({
                                                                                   ({
                                                                                        ({
                                                                                             ({
                                                                                                  ({
                                                                                                       ({
                                                                                                            ({
                                                                                                                 ({
                                                                                                                      ({
                                                                                                                           ({
                                                                                                                                0
                                                                                                                            }
                                                                                                                                |
                                                                                                                                ((TPMA_NV_PPWRITE
                                                                                                                                      as
                                                                                                                                      u32
                                                                                                                                      as
                                                                                                                                      u32)
                                                                                                                                     <<
                                                                                                                                     0usize)
                                                                                                                                    &
                                                                                                                                    (1usize
                                                                                                                                         as
                                                                                                                                         u32))
                                                                                                                       }
                                                                                                                           |
                                                                                                                           ((TPMA_NV_OWNERWRITE
                                                                                                                                 as
                                                                                                                                 u32
                                                                                                                                 as
                                                                                                                                 u32)
                                                                                                                                <<
                                                                                                                                1usize)
                                                                                                                               &
                                                                                                                               (2usize
                                                                                                                                    as
                                                                                                                                    u32))
                                                                                                                  }
                                                                                                                      |
                                                                                                                      ((TPMA_NV_AUTHWRITE
                                                                                                                            as
                                                                                                                            u32
                                                                                                                            as
                                                                                                                            u32)
                                                                                                                           <<
                                                                                                                           2usize)
                                                                                                                          &
                                                                                                                          (4usize
                                                                                                                               as
                                                                                                                               u32))
                                                                                                             }
                                                                                                                 |
                                                                                                                 ((TPMA_NV_POLICYWRITE
                                                                                                                       as
                                                                                                                       u32
                                                                                                                       as
                                                                                                                       u32)
                                                                                                                      <<
                                                                                                                      3usize)
                                                                                                                     &
                                                                                                                     (8usize
                                                                                                                          as
                                                                                                                          u32))
                                                                                                        }
                                                                                                            |
                                                                                                            ((TPM_NT
                                                                                                                  as
                                                                                                                  u32
                                                                                                                  as
                                                                                                                  u32)
                                                                                                                 <<
                                                                                                                 4usize)
                                                                                                                &
                                                                                                                (240usize
                                                                                                                     as
                                                                                                                     u32))
                                                                                                   }
                                                                                                       |
                                                                                                       ((reserved1
                                                                                                             as
                                                                                                             u32
                                                                                                             as
                                                                                                             u32)
                                                                                                            <<
                                                                                                            8usize)
                                                                                                           &
                                                                                                           (768usize
                                                                                                                as
                                                                                                                u32))
                                                                                              }
                                                                                                  |
                                                                                                  ((TPMA_NV_POLICY_DELETE
                                                                                                        as
                                                                                                        u32
                                                                                                        as
                                                                                                        u32)
                                                                                                       <<
                                                                                                       10usize)
                                                                                                      &
                                                                                                      (1024usize
                                                                                                           as
                                                                                                           u32))
                                                                                         }
                                                                                             |
                                                                                             ((TPMA_NV_WRITELOCKED
                                                                                                   as
                                                                                                   u32
                                                                                                   as
                                                                                                   u32)
                                                                                                  <<
                                                                                                  11usize)
                                                                                                 &
                                                                                                 (2048usize
                                                                                                      as
                                                                                                      u32))
                                                                                    }
                                                                                        |
                                                                                        ((TPMA_NV_WRITEALL
                                                                                              as
                                                                                              u32
                                                                                              as
                                                                                              u32)
                                                                                             <<
                                                                                             12usize)
                                                                                            &
                                                                                            (4096usize
                                                                                                 as
                                                                                                 u32))
                                                                               }
                                                                                   |
                                                                                   ((TPMA_NV_WRITEDEFINE
                                                                                         as
                                                                                         u32
                                                                                         as
                                                                                         u32)
                                                                                        <<
                                                                                        13usize)
                                                                                       &
                                                                                       (8192usize
                                                                                            as
                                                                                            u32))
                                                                          } |
                                                                              ((TPMA_NV_WRITE_STCLEAR
                                                                                    as
                                                                                    u32
                                                                                    as
                                                                                    u32)
                                                                                   <<
                                                                                   14usize)
                                                                                  &
                                                                                  (16384usize
                                                                                       as
                                                                                       u32))
                                                                     } |
                                                                         ((TPMA_NV_GLOBALLOCK
                                                                               as
                                                                               u32
                                                                               as
                                                                               u32)
                                                                              <<
                                                                              15usize)
                                                                             &
                                                                             (32768usize
                                                                                  as
                                                                                  u32))
                                                                } |
                                                                    ((TPMA_NV_PPREAD
                                                                          as
                                                                          u32
                                                                          as
                                                                          u32)
                                                                         <<
                                                                         16usize)
                                                                        &
                                                                        (65536usize
                                                                             as
                                                                             u32))
                                                           } |
                                                               ((TPMA_NV_OWNERREAD
                                                                     as u32 as
                                                                     u32) <<
                                                                    17usize) &
                                                                   (131072usize
                                                                        as
                                                                        u32))
                                                      } |
                                                          ((TPMA_NV_AUTHREAD
                                                                as u32 as u32)
                                                               << 18usize) &
                                                              (262144usize as
                                                                   u32))
                                                 } |
                                                     ((TPMA_NV_POLICYREAD as
                                                           u32 as u32) <<
                                                          19usize) &
                                                         (524288usize as u32))
                                            } |
                                                ((reserved2 as u32 as u32) <<
                                                     20usize) &
                                                    (32505856usize as u32))
                                       } |
                                           ((TPMA_NV_NO_DA as u32 as u32) <<
                                                25usize) &
                                               (33554432usize as u32))
                                  } |
                                      ((TPMA_NV_ORDERLY as u32 as u32) <<
                                           26usize) & (67108864usize as u32))
                             } |
                                 ((TPMA_NV_CLEAR_STCLEAR as u32 as u32) <<
                                      27usize) & (134217728usize as u32))
                        } |
                            ((TPMA_NV_READLOCKED as u32 as u32) << 28usize) &
                                (268435456usize as u32))
                   } |
                       ((TPMA_NV_WRITTEN as u32 as u32) << 29usize) &
                           (536870912usize as u32))
              } |
                  ((TPMA_NV_PLATFORMCREATE as u32 as u32) << 30usize) &
                      (1073741824usize as u32))
         } |
             ((TPMA_NV_READ_STCLEAR as u32 as u32) << 31usize) &
                 (2147483648usize as u32))
    }
}
#[test]
fn bindgen_test_layout_TPMA_NV() {
    assert_eq!(::std::mem::size_of::<TPMA_NV>() , 4usize , concat ! (
               "Size of: " , stringify ! ( TPMA_NV ) ));
    assert_eq! (::std::mem::align_of::<TPMA_NV>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMA_NV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMA_NV ) ) . val as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMA_NV ) , "::" ,
                stringify ! ( val ) ));
}
impl Clone for TPMA_NV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_NV_PUBLIC {
    pub nvIndex: TPMI_RH_NV_INDEX,
    pub nameAlg: TPMI_ALG_HASH,
    pub attributes: TPMA_NV,
    pub authPolicy: TPM2B_DIGEST,
    pub dataSize: UINT16,
}
#[test]
fn bindgen_test_layout_TPMS_NV_PUBLIC() {
    assert_eq!(::std::mem::size_of::<TPMS_NV_PUBLIC>() , 80usize , concat ! (
               "Size of: " , stringify ! ( TPMS_NV_PUBLIC ) ));
    assert_eq! (::std::mem::align_of::<TPMS_NV_PUBLIC>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_NV_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PUBLIC ) ) . nvIndex as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_PUBLIC ) , "::"
                , stringify ! ( nvIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PUBLIC ) ) . nameAlg as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_PUBLIC ) , "::"
                , stringify ! ( nameAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PUBLIC ) ) . attributes as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_PUBLIC ) , "::"
                , stringify ! ( attributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PUBLIC ) ) . authPolicy as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_PUBLIC ) , "::"
                , stringify ! ( authPolicy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_NV_PUBLIC ) ) . dataSize as * const
                _ as usize } , 78usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_NV_PUBLIC ) , "::"
                , stringify ! ( dataSize ) ));
}
impl Clone for TPMS_NV_PUBLIC {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_NV_PUBLIC {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM2B_NV_PUBLIC {
    pub t: __BindgenUnionField<TPM2B_NV_PUBLIC__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u32; 21usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_NV_PUBLIC__bindgen_ty_1 {
    pub size: UINT16,
    pub nvPublic: TPMS_NV_PUBLIC,
}
#[test]
fn bindgen_test_layout_TPM2B_NV_PUBLIC__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_NV_PUBLIC__bindgen_ty_1>() ,
               84usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_NV_PUBLIC__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_NV_PUBLIC__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPM2B_NV_PUBLIC__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NV_PUBLIC__bindgen_ty_1 ) ) . size
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_NV_PUBLIC__bindgen_ty_1 ) , "::" , stringify ! ( size )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NV_PUBLIC__bindgen_ty_1 ) ) .
                nvPublic as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_NV_PUBLIC__bindgen_ty_1 ) , "::" , stringify ! (
                nvPublic ) ));
}
impl Clone for TPM2B_NV_PUBLIC__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_NV_PUBLIC__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_NV_PUBLIC() {
    assert_eq!(::std::mem::size_of::<TPM2B_NV_PUBLIC>() , 84usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_NV_PUBLIC ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_NV_PUBLIC>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TPM2B_NV_PUBLIC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NV_PUBLIC ) ) . t as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_NV_PUBLIC ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_NV_PUBLIC ) ) . b as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_NV_PUBLIC ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_NV_PUBLIC {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_CONTEXT_SENSITIVE {
    pub t: __BindgenUnionField<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 1025usize],
}
#[repr(C)]
pub struct TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 2048usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>()
               , 2050usize , concat ! (
               "Size of: " , stringify ! (
               TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) )
                . size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) )
                . buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_CONTEXT_SENSITIVE__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_SENSITIVE() {
    assert_eq!(::std::mem::size_of::<TPM2B_CONTEXT_SENSITIVE>() , 2050usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM2B_CONTEXT_SENSITIVE ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_CONTEXT_SENSITIVE>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_CONTEXT_SENSITIVE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_SENSITIVE ) ) . t as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_SENSITIVE ) ) . b as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CONTEXT_SENSITIVE
                ) , "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_CONTEXT_SENSITIVE {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_CONTEXT_SENSITIVE {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CONTEXT_DATA {
    pub integrity: TPM2B_DIGEST,
    pub encrypted: TPM2B_CONTEXT_SENSITIVE,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT_DATA() {
    assert_eq!(::std::mem::size_of::<TPMS_CONTEXT_DATA>() , 2116usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_CONTEXT_DATA ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CONTEXT_DATA>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_CONTEXT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT_DATA ) ) . integrity as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT_DATA ) ,
                "::" , stringify ! ( integrity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT_DATA ) ) . encrypted as *
                const _ as usize } , 66usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT_DATA ) ,
                "::" , stringify ! ( encrypted ) ));
}
impl Clone for TPMS_CONTEXT_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CONTEXT_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_CONTEXT_DATA {
    pub t: __BindgenUnionField<TPM2B_CONTEXT_DATA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u16; 1059usize],
}
#[repr(C)]
pub struct TPM2B_CONTEXT_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub buffer: [BYTE; 2116usize],
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_DATA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_CONTEXT_DATA__bindgen_ty_1>() ,
               2118usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_CONTEXT_DATA__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_CONTEXT_DATA__bindgen_ty_1>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_CONTEXT_DATA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_DATA__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CONTEXT_DATA__bindgen_ty_1 ) , "::" , stringify ! ( size
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_DATA__bindgen_ty_1 ) ) .
                buffer as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CONTEXT_DATA__bindgen_ty_1 ) , "::" , stringify ! (
                buffer ) ));
}
impl Default for TPM2B_CONTEXT_DATA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_CONTEXT_DATA() {
    assert_eq!(::std::mem::size_of::<TPM2B_CONTEXT_DATA>() , 2118usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_CONTEXT_DATA ) ));
    assert_eq! (::std::mem::align_of::<TPM2B_CONTEXT_DATA>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( TPM2B_CONTEXT_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_DATA ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CONTEXT_DATA ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CONTEXT_DATA ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CONTEXT_DATA ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_CONTEXT_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_CONTEXT_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CONTEXT {
    pub sequence: UINT64,
    pub savedHandle: TPMI_DH_CONTEXT,
    pub hierarchy: TPMI_RH_HIERARCHY,
    pub contextBlob: TPM2B_CONTEXT_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CONTEXT() {
    assert_eq!(::std::mem::size_of::<TPMS_CONTEXT>() , 2136usize , concat ! (
               "Size of: " , stringify ! ( TPMS_CONTEXT ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CONTEXT>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( TPMS_CONTEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT ) ) . sequence as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT ) , "::" ,
                stringify ! ( sequence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT ) ) . savedHandle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT ) , "::" ,
                stringify ! ( savedHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT ) ) . hierarchy as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT ) , "::" ,
                stringify ! ( hierarchy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CONTEXT ) ) . contextBlob as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CONTEXT ) , "::" ,
                stringify ! ( contextBlob ) ));
}
impl Clone for TPMS_CONTEXT {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CONTEXT {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPMS_CREATION_DATA {
    pub pcrSelect: TPML_PCR_SELECTION,
    pub pcrDigest: TPM2B_DIGEST,
    pub locality: TPMA_LOCALITY,
    pub parentNameAlg: TPM_ALG_ID,
    pub parentName: TPM2B_NAME,
    pub parentQualifiedName: TPM2B_NAME,
    pub outsideInfo: TPM2B_DATA,
}
#[test]
fn bindgen_test_layout_TPMS_CREATION_DATA() {
    assert_eq!(::std::mem::size_of::<TPMS_CREATION_DATA>() , 320usize , concat
               ! ( "Size of: " , stringify ! ( TPMS_CREATION_DATA ) ));
    assert_eq! (::std::mem::align_of::<TPMS_CREATION_DATA>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPMS_CREATION_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . pcrSelect as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( pcrSelect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . pcrDigest as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( pcrDigest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . locality as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( locality ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . parentNameAlg as
                * const _ as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( parentNameAlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . parentName as *
                const _ as usize } , 110usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( parentName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) .
                parentQualifiedName as * const _ as usize } , 180usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( parentQualifiedName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPMS_CREATION_DATA ) ) . outsideInfo as *
                const _ as usize } , 250usize , concat ! (
                "Alignment of field: " , stringify ! ( TPMS_CREATION_DATA ) ,
                "::" , stringify ! ( outsideInfo ) ));
}
impl Clone for TPMS_CREATION_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPMS_CREATION_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_CREATION_DATA {
    pub t: __BindgenUnionField<TPM2B_CREATION_DATA__bindgen_ty_1>,
    pub b: __BindgenUnionField<TPM2B>,
    pub bindgen_union_field: [u32; 81usize],
}
#[repr(C)]
#[derive(Copy)]
pub struct TPM2B_CREATION_DATA__bindgen_ty_1 {
    pub size: UINT16,
    pub creationData: TPMS_CREATION_DATA,
}
#[test]
fn bindgen_test_layout_TPM2B_CREATION_DATA__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<TPM2B_CREATION_DATA__bindgen_ty_1>() ,
               324usize , concat ! (
               "Size of: " , stringify ! ( TPM2B_CREATION_DATA__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_CREATION_DATA__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM2B_CREATION_DATA__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CREATION_DATA__bindgen_ty_1 ) ) .
                size as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CREATION_DATA__bindgen_ty_1 ) , "::" , stringify ! (
                size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CREATION_DATA__bindgen_ty_1 ) ) .
                creationData as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM2B_CREATION_DATA__bindgen_ty_1 ) , "::" , stringify ! (
                creationData ) ));
}
impl Clone for TPM2B_CREATION_DATA__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_CREATION_DATA__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_TPM2B_CREATION_DATA() {
    assert_eq!(::std::mem::size_of::<TPM2B_CREATION_DATA>() , 324usize ,
               concat ! ( "Size of: " , stringify ! ( TPM2B_CREATION_DATA )
               ));
    assert_eq! (::std::mem::align_of::<TPM2B_CREATION_DATA>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM2B_CREATION_DATA ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CREATION_DATA ) ) . t as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CREATION_DATA ) ,
                "::" , stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM2B_CREATION_DATA ) ) . b as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM2B_CREATION_DATA ) ,
                "::" , stringify ! ( b ) ));
}
impl Clone for TPM2B_CREATION_DATA {
    fn clone(&self) -> Self { *self }
}
impl Default for TPM2B_CREATION_DATA {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type nfds_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(::std::mem::size_of::<pollfd>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pollfd ) ));
    assert_eq! (::std::mem::align_of::<pollfd>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pollfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pollfd ) ) . fd as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( pollfd ) , "::" ,
                stringify ! ( fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pollfd ) ) . events as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pollfd ) , "::" ,
                stringify ! ( events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pollfd ) ) . revents as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( pollfd ) , "::" ,
                stringify ! ( revents ) ));
}
impl Clone for pollfd {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn poll(__fds: *mut pollfd, __nfds: nfds_t,
                __timeout: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type TSS2_TCTI_POLL_HANDLE = pollfd;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSS2_TCTI_OPAQUE_CONTEXT_BLOB {
    _unused: [u8; 0],
}
pub type TSS2_TCTI_CONTEXT = TSS2_TCTI_OPAQUE_CONTEXT_BLOB;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TSS2_TCTI_CONTEXT_VERSION {
    pub magic: u64,
    pub version: u32,
}
#[test]
fn bindgen_test_layout_TSS2_TCTI_CONTEXT_VERSION() {
    assert_eq!(::std::mem::size_of::<TSS2_TCTI_CONTEXT_VERSION>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TSS2_TCTI_CONTEXT_VERSION ) ));
    assert_eq! (::std::mem::align_of::<TSS2_TCTI_CONTEXT_VERSION>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( TSS2_TCTI_CONTEXT_VERSION )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_VERSION ) ) . magic as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_VERSION ) , "::" , stringify ! ( magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_VERSION ) ) . version
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_VERSION ) , "::" , stringify ! ( version )
                ));
}
impl Clone for TSS2_TCTI_CONTEXT_VERSION {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TSS2_TCTI_CONTEXT_COMMON_V1 {
    pub magic: u64,
    pub version: u32,
    pub transmit: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                                 *mut TSS2_TCTI_CONTEXT,
                                                             size: usize,
                                                             command: *mut u8)
                                            -> TSS2_RC>,
    pub receive: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                                *mut TSS2_TCTI_CONTEXT,
                                                            size: *mut usize,
                                                            response: *mut u8,
                                                            timeout: i32)
                                           -> TSS2_RC>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                                 *mut TSS2_TCTI_CONTEXT)>,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                               *mut TSS2_TCTI_CONTEXT)
                                          -> TSS2_RC>,
    pub getPollHandles: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                                       *mut TSS2_TCTI_CONTEXT,
                                                                   handles:
                                                                       *mut TSS2_TCTI_POLL_HANDLE,
                                                                   num_handles:
                                                                       *mut usize)
                                                  -> TSS2_RC>,
    pub setLocality: ::std::option::Option<unsafe extern "C" fn(tctiContext:
                                                                    *mut TSS2_TCTI_CONTEXT,
                                                                locality: u8)
                                               -> TSS2_RC>,
}
#[test]
fn bindgen_test_layout_TSS2_TCTI_CONTEXT_COMMON_V1() {
    assert_eq!(::std::mem::size_of::<TSS2_TCTI_CONTEXT_COMMON_V1>() , 64usize
               , concat ! (
               "Size of: " , stringify ! ( TSS2_TCTI_CONTEXT_COMMON_V1 ) ));
    assert_eq! (::std::mem::align_of::<TSS2_TCTI_CONTEXT_COMMON_V1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( TSS2_TCTI_CONTEXT_COMMON_V1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) . magic
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( magic )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) . version
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( version )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) .
                transmit as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( transmit
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) . receive
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( receive )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) .
                finalize as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( finalize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) . cancel
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! ( cancel )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) .
                getPollHandles as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! (
                getPollHandles ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_TCTI_CONTEXT_COMMON_V1 ) ) .
                setLocality as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                TSS2_TCTI_CONTEXT_COMMON_V1 ) , "::" , stringify ! (
                setLocality ) ));
}
impl Clone for TSS2_TCTI_CONTEXT_COMMON_V1 {
    fn clone(&self) -> Self { *self }
}
impl Default for TSS2_TCTI_CONTEXT_COMMON_V1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type TSS2_TCTI_CONTEXT_COMMON_CURRENT = TSS2_TCTI_CONTEXT_COMMON_V1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TSS2_SYS_OPAQUE_CONTEXT_BLOB {
    _unused: [u8; 0],
}
pub type TSS2_SYS_CONTEXT = _TSS2_SYS_OPAQUE_CONTEXT_BLOB;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TSS2_SYS_CMD_AUTHS {
    pub cmdAuthsCount: u8,
    pub cmdAuths: *mut *mut TPMS_AUTH_COMMAND,
}
#[test]
fn bindgen_test_layout_TSS2_SYS_CMD_AUTHS() {
    assert_eq!(::std::mem::size_of::<TSS2_SYS_CMD_AUTHS>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TSS2_SYS_CMD_AUTHS ) ));
    assert_eq! (::std::mem::align_of::<TSS2_SYS_CMD_AUTHS>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TSS2_SYS_CMD_AUTHS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_SYS_CMD_AUTHS ) ) . cmdAuthsCount as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_SYS_CMD_AUTHS ) ,
                "::" , stringify ! ( cmdAuthsCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_SYS_CMD_AUTHS ) ) . cmdAuths as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_SYS_CMD_AUTHS ) ,
                "::" , stringify ! ( cmdAuths ) ));
}
impl Clone for TSS2_SYS_CMD_AUTHS {
    fn clone(&self) -> Self { *self }
}
impl Default for TSS2_SYS_CMD_AUTHS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TSS2_SYS_RSP_AUTHS {
    pub rspAuthsCount: u8,
    pub rspAuths: *mut *mut TPMS_AUTH_RESPONSE,
}
#[test]
fn bindgen_test_layout_TSS2_SYS_RSP_AUTHS() {
    assert_eq!(::std::mem::size_of::<TSS2_SYS_RSP_AUTHS>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TSS2_SYS_RSP_AUTHS ) ));
    assert_eq! (::std::mem::align_of::<TSS2_SYS_RSP_AUTHS>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( TSS2_SYS_RSP_AUTHS ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_SYS_RSP_AUTHS ) ) . rspAuthsCount as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_SYS_RSP_AUTHS ) ,
                "::" , stringify ! ( rspAuthsCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TSS2_SYS_RSP_AUTHS ) ) . rspAuths as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TSS2_SYS_RSP_AUTHS ) ,
                "::" , stringify ! ( rspAuths ) ));
}
impl Clone for TSS2_SYS_RSP_AUTHS {
    fn clone(&self) -> Self { *self }
}
impl Default for TSS2_SYS_RSP_AUTHS {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn Tss2_Sys_GetContextSize(maxCommandResponseSize: usize) -> usize;
}
extern "C" {
    pub fn Tss2_Sys_Initialize(sysContext: *mut TSS2_SYS_CONTEXT,
                               contextSize: usize,
                               tctiContext: *mut TSS2_TCTI_CONTEXT,
                               abiVersion: *mut TSS2_ABI_VERSION) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Finalize(sysContext: *mut TSS2_SYS_CONTEXT);
}
extern "C" {
    pub fn Tss2_Sys_GetTctiContext(sysContext: *mut TSS2_SYS_CONTEXT,
                                   tctiContext: *mut *mut TSS2_TCTI_CONTEXT)
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetDecryptParam(sysContext: *mut TSS2_SYS_CONTEXT,
                                    decryptParamSize: *mut usize,
                                    decryptParamBuffer: *mut *const u8)
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetDecryptParam(sysContext: *mut TSS2_SYS_CONTEXT,
                                    decryptParamSize: usize,
                                    decryptParamBuffer: *const u8) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCpBuffer(sysContext: *mut TSS2_SYS_CONTEXT,
                                cpBufferUsedSize: *mut usize,
                                cpBuffer: *mut *const u8) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCmdAuths(sysContext: *mut TSS2_SYS_CONTEXT,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ExecuteAsync(sysContext: *mut TSS2_SYS_CONTEXT)
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_ExecuteFinish(sysContext: *mut TSS2_SYS_CONTEXT,
                                  timeout: i32) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_Execute(sysContext: *mut TSS2_SYS_CONTEXT) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandCode(sysContext: *mut TSS2_SYS_CONTEXT,
                                   commandCode:
                                       *mut [::std::os::raw::c_uchar; 4usize])
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRspAuths(sysContext: *mut TSS2_SYS_CONTEXT,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetEncryptParam(sysContext: *mut TSS2_SYS_CONTEXT,
                                    encryptParamSize: *mut usize,
                                    encryptParamBuffer: *mut *const u8)
     -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetEncryptParam(sysContext: *mut TSS2_SYS_CONTEXT,
                                    encryptParamSize: usize,
                                    encryptParamBuffer: *const u8) -> TSS2_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRpBuffer(sysContext: *mut TSS2_SYS_CONTEXT,
                                rpBufferUsedSize: *mut usize,
                                rpBuffer: *mut *const u8) -> TPM_RC;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_Startup_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_Startup_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_Startup_Out>() , 16usize , concat !
               ( "Size of: " , stringify ! ( TPM20_Startup_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_Startup_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_Startup_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Startup_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Startup_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Startup_Out ) ) . responseSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Startup_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Startup_Out ) ) . responseCode as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Startup_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Startup_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Startup_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_Startup_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_Shutdown_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_Shutdown_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_Shutdown_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_Shutdown_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_Shutdown_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_Shutdown_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Shutdown_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Shutdown_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Shutdown_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Shutdown_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Shutdown_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Shutdown_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Shutdown_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Shutdown_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_Shutdown_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_SelfTest_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_SelfTest_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_SelfTest_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_SelfTest_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_SelfTest_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_SelfTest_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SelfTest_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_SelfTest_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SelfTest_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_SelfTest_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SelfTest_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_SelfTest_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SelfTest_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_SelfTest_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_SelfTest_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyRestart_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyRestart_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyRestart_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyRestart_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyRestart_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyRestart_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyRestart_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyRestart_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyRestart_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyRestart_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyRestart_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyRestart_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyRestart_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyRestart_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyRestart_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_StirRandom_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_StirRandom_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_StirRandom_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_StirRandom_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_StirRandom_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_StirRandom_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_StirRandom_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_StirRandom_Out )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_StirRandom_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_StirRandom_Out )
                , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_StirRandom_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_StirRandom_Out )
                , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_StirRandom_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_StirRandom_Out )
                , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_StirRandom_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_SequenceUpdate_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_SequenceUpdate_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_SequenceUpdate_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_SequenceUpdate_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_SequenceUpdate_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_SequenceUpdate_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SequenceUpdate_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SequenceUpdate_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SequenceUpdate_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SequenceUpdate_Out ) , "::" , stringify ! ( responseSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SequenceUpdate_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SequenceUpdate_Out ) , "::" , stringify ! ( responseCode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SequenceUpdate_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SequenceUpdate_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_SequenceUpdate_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_SetCommandCodeAuditStatus_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_SetCommandCodeAuditStatus_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_SetCommandCodeAuditStatus_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_SetCommandCodeAuditStatus_Out
               ) ));
    assert_eq! (::std::mem::align_of::<TPM20_SetCommandCodeAuditStatus_Out>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_SetCommandCodeAuditStatus_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetCommandCodeAuditStatus_Out ) ) .
                tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetCommandCodeAuditStatus_Out ) , "::" , stringify ! (
                tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetCommandCodeAuditStatus_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetCommandCodeAuditStatus_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetCommandCodeAuditStatus_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetCommandCodeAuditStatus_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetCommandCodeAuditStatus_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetCommandCodeAuditStatus_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_SetCommandCodeAuditStatus_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PCR_Extend_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PCR_Extend_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PCR_Extend_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_PCR_Extend_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PCR_Extend_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PCR_Extend_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Extend_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Extend_Out )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Extend_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Extend_Out )
                , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Extend_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Extend_Out )
                , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Extend_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Extend_Out )
                , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PCR_Extend_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PCR_SetAuthPolicy_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PCR_SetAuthPolicy_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PCR_SetAuthPolicy_Out>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( TPM20_PCR_SetAuthPolicy_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PCR_SetAuthPolicy_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_PCR_SetAuthPolicy_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthPolicy_Out ) ) . tag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthPolicy_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthPolicy_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthPolicy_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthPolicy_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthPolicy_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthPolicy_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthPolicy_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_PCR_SetAuthPolicy_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PCR_SetAuthValue_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PCR_SetAuthValue_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PCR_SetAuthValue_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PCR_SetAuthValue_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PCR_SetAuthValue_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_PCR_SetAuthValue_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthValue_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthValue_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthValue_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthValue_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthValue_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthValue_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_SetAuthValue_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PCR_SetAuthValue_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_PCR_SetAuthValue_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PCR_Reset_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PCR_Reset_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PCR_Reset_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_PCR_Reset_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PCR_Reset_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PCR_Reset_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Reset_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Reset_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Reset_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Reset_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Reset_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Reset_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PCR_Reset_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PCR_Reset_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PCR_Reset_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyTicket_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyTicket_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyTicket_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_PolicyTicket_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyTicket_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyTicket_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyTicket_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyTicket_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyTicket_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyTicket_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyTicket_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyTicket_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyTicket_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyTicket_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyTicket_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyOR_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyOR_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyOR_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_PolicyOR_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyOR_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_PolicyOR_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyOR_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyOR_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyOR_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyOR_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyOR_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyOR_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyOR_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyOR_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyOR_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyPCR_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyPCR_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyPCR_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_PolicyPCR_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyPCR_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyPCR_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPCR_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyPCR_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPCR_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyPCR_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPCR_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyPCR_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPCR_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyPCR_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyPCR_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyLocality_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyLocality_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyLocality_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyLocality_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyLocality_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyLocality_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyLocality_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyLocality_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyLocality_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyLocality_Out ) , "::" , stringify ! ( responseSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyLocality_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyLocality_Out ) , "::" , stringify ! ( responseCode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyLocality_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyLocality_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyLocality_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyNV_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyNV_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyNV_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_PolicyNV_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyNV_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_PolicyNV_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNV_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyNV_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNV_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyNV_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNV_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyNV_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNV_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyNV_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyNV_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyCounterTimer_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyCounterTimer_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyCounterTimer_Out>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyCounterTimer_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyCounterTimer_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyCounterTimer_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCounterTimer_Out ) ) . tag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCounterTimer_Out ) , "::" , stringify ! ( tag )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCounterTimer_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCounterTimer_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCounterTimer_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCounterTimer_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCounterTimer_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCounterTimer_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_PolicyCounterTimer_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyCommandCode_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyCommandCode_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyCommandCode_Out>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyCommandCode_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyCommandCode_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyCommandCode_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCommandCode_Out ) ) . tag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCommandCode_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCommandCode_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCommandCode_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCommandCode_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCommandCode_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCommandCode_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyCommandCode_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_PolicyCommandCode_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyPhysicalPresence_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyPhysicalPresence_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyPhysicalPresence_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyPhysicalPresence_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyPhysicalPresence_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_PolicyPhysicalPresence_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPhysicalPresence_Out ) ) .
                tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPhysicalPresence_Out ) , "::" , stringify ! ( tag
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPhysicalPresence_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPhysicalPresence_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPhysicalPresence_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPhysicalPresence_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPhysicalPresence_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPhysicalPresence_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_PolicyPhysicalPresence_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyCpHash_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyCpHash_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyCpHash_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_PolicyCpHash_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyCpHash_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyCpHash_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCpHash_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyCpHash_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCpHash_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyCpHash_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCpHash_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyCpHash_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyCpHash_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PolicyCpHash_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PolicyCpHash_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyNameHash_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyNameHash_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyNameHash_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyNameHash_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyNameHash_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyNameHash_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNameHash_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNameHash_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNameHash_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNameHash_Out ) , "::" , stringify ! ( responseSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNameHash_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNameHash_Out ) , "::" , stringify ! ( responseCode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNameHash_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNameHash_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyNameHash_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyDuplicationSelect_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyDuplicationSelect_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyDuplicationSelect_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyDuplicationSelect_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyDuplicationSelect_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_PolicyDuplicationSelect_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyDuplicationSelect_Out ) ) .
                tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyDuplicationSelect_Out ) , "::" , stringify ! ( tag
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyDuplicationSelect_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyDuplicationSelect_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyDuplicationSelect_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyDuplicationSelect_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyDuplicationSelect_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyDuplicationSelect_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_PolicyDuplicationSelect_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyAuthorize_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyAuthorize_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyAuthorize_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyAuthorize_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyAuthorize_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyAuthorize_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthorize_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthorize_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthorize_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthorize_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthorize_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthorize_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthorize_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthorize_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyAuthorize_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyAuthValue_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyAuthValue_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyAuthValue_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyAuthValue_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyAuthValue_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyAuthValue_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthValue_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthValue_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthValue_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthValue_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthValue_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthValue_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyAuthValue_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyAuthValue_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyAuthValue_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyPassword_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyPassword_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyPassword_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyPassword_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyPassword_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyPassword_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPassword_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPassword_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPassword_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPassword_Out ) , "::" , stringify ! ( responseSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPassword_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPassword_Out ) , "::" , stringify ! ( responseCode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyPassword_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyPassword_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyPassword_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PolicyNvWritten_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PolicyNvWritten_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PolicyNvWritten_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_PolicyNvWritten_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_PolicyNvWritten_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PolicyNvWritten_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNvWritten_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNvWritten_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNvWritten_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNvWritten_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNvWritten_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNvWritten_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PolicyNvWritten_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_PolicyNvWritten_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_PolicyNvWritten_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_HierarchyControl_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_HierarchyControl_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_HierarchyControl_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_HierarchyControl_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_HierarchyControl_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_HierarchyControl_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyControl_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyControl_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyControl_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyControl_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyControl_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyControl_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyControl_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyControl_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_HierarchyControl_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_SetPrimaryPolicy_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_SetPrimaryPolicy_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_SetPrimaryPolicy_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_SetPrimaryPolicy_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_SetPrimaryPolicy_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_SetPrimaryPolicy_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetPrimaryPolicy_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetPrimaryPolicy_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetPrimaryPolicy_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetPrimaryPolicy_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetPrimaryPolicy_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetPrimaryPolicy_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetPrimaryPolicy_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetPrimaryPolicy_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_SetPrimaryPolicy_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_ChangePPS_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_ChangePPS_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ChangePPS_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_ChangePPS_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_ChangePPS_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_ChangePPS_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangePPS_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangePPS_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangePPS_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangePPS_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangePPS_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangePPS_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangePPS_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangePPS_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_ChangePPS_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_ChangeEPS_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_ChangeEPS_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ChangeEPS_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_ChangeEPS_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_ChangeEPS_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_ChangeEPS_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangeEPS_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangeEPS_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangeEPS_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangeEPS_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangeEPS_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangeEPS_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ChangeEPS_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ChangeEPS_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_ChangeEPS_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_Clear_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_Clear_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_Clear_Out>() , 16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_Clear_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_Clear_Out>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( TPM20_Clear_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Clear_Out ) ) . tag as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Clear_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Clear_Out ) ) . responseSize as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Clear_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Clear_Out ) ) . responseCode as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Clear_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_Clear_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_Clear_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_Clear_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_ClearControl_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_ClearControl_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ClearControl_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_ClearControl_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_ClearControl_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_ClearControl_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClearControl_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClearControl_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClearControl_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClearControl_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClearControl_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClearControl_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClearControl_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClearControl_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_ClearControl_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_HierarchyChangeAuth_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_HierarchyChangeAuth_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_HierarchyChangeAuth_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_HierarchyChangeAuth_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_HierarchyChangeAuth_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPM20_HierarchyChangeAuth_Out
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyChangeAuth_Out ) ) . tag
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyChangeAuth_Out ) , "::" , stringify ! ( tag )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyChangeAuth_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyChangeAuth_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyChangeAuth_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyChangeAuth_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_HierarchyChangeAuth_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_HierarchyChangeAuth_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_HierarchyChangeAuth_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_DictionaryAttackLockReset_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_DictionaryAttackLockReset_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_DictionaryAttackLockReset_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_DictionaryAttackLockReset_Out
               ) ));
    assert_eq! (::std::mem::align_of::<TPM20_DictionaryAttackLockReset_Out>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_DictionaryAttackLockReset_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackLockReset_Out ) ) .
                tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackLockReset_Out ) , "::" , stringify ! (
                tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackLockReset_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackLockReset_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackLockReset_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackLockReset_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackLockReset_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackLockReset_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_DictionaryAttackLockReset_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_DictionaryAttackParameters_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_DictionaryAttackParameters_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_DictionaryAttackParameters_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! (
               TPM20_DictionaryAttackParameters_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_DictionaryAttackParameters_Out>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_DictionaryAttackParameters_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackParameters_Out ) )
                . tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackParameters_Out ) , "::" , stringify ! (
                tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackParameters_Out ) )
                . responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackParameters_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackParameters_Out ) )
                . responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackParameters_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_DictionaryAttackParameters_Out ) )
                . otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_DictionaryAttackParameters_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_DictionaryAttackParameters_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_PP_Commands_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_PP_Commands_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_PP_Commands_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_PP_Commands_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_PP_Commands_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_PP_Commands_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PP_Commands_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PP_Commands_Out )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PP_Commands_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PP_Commands_Out )
                , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PP_Commands_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PP_Commands_Out )
                , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_PP_Commands_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_PP_Commands_Out )
                , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_PP_Commands_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_SetAlgorithmSet_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_SetAlgorithmSet_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_SetAlgorithmSet_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_SetAlgorithmSet_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_SetAlgorithmSet_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_SetAlgorithmSet_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetAlgorithmSet_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetAlgorithmSet_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetAlgorithmSet_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetAlgorithmSet_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetAlgorithmSet_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetAlgorithmSet_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_SetAlgorithmSet_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_SetAlgorithmSet_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_SetAlgorithmSet_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_FieldUpgradeStart_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_FieldUpgradeStart_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_FieldUpgradeStart_Out>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( TPM20_FieldUpgradeStart_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_FieldUpgradeStart_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_FieldUpgradeStart_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FieldUpgradeStart_Out ) ) . tag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_FieldUpgradeStart_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FieldUpgradeStart_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_FieldUpgradeStart_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FieldUpgradeStart_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_FieldUpgradeStart_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FieldUpgradeStart_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_FieldUpgradeStart_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_FieldUpgradeStart_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_FlushContext_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_FlushContext_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_FlushContext_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_FlushContext_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_FlushContext_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_FlushContext_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FlushContext_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_FlushContext_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FlushContext_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_FlushContext_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FlushContext_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_FlushContext_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_FlushContext_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_FlushContext_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_FlushContext_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_EvictControl_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_EvictControl_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_EvictControl_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_EvictControl_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_EvictControl_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_EvictControl_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_EvictControl_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_EvictControl_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_EvictControl_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_EvictControl_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_EvictControl_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_EvictControl_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_EvictControl_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_EvictControl_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_EvictControl_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_ClockSet_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_ClockSet_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ClockSet_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_ClockSet_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_ClockSet_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_ClockSet_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockSet_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClockSet_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockSet_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClockSet_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockSet_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClockSet_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockSet_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_ClockSet_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_ClockSet_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_ClockRateAdjust_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_ClockRateAdjust_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_ClockRateAdjust_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_ClockRateAdjust_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_ClockRateAdjust_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_ClockRateAdjust_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_ClockRateAdjust_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_ClockRateAdjust_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_ClockRateAdjust_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_TestParms_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_TestParms_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_TestParms_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_TestParms_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_TestParms_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_TestParms_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_TestParms_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_TestParms_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_TestParms_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_TestParms_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_TestParms_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_TestParms_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_TestParms_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_TestParms_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_TestParms_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_DefineSpace_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_DefineSpace_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_DefineSpace_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_NV_DefineSpace_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_DefineSpace_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_DefineSpace_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_DefineSpace_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_DefineSpace_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_DefineSpace_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_DefineSpace_Out ) , "::" , stringify ! ( responseSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_DefineSpace_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_DefineSpace_Out ) , "::" , stringify ! ( responseCode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_DefineSpace_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_DefineSpace_Out ) , "::" , stringify ! ( otherData )
                ));
}
impl Clone for TPM20_NV_DefineSpace_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_UndefineSpace_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_UndefineSpace_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_UndefineSpace_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_NV_UndefineSpace_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_UndefineSpace_Out>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_UndefineSpace_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpace_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpace_Out ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpace_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpace_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpace_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpace_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpace_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpace_Out ) , "::" , stringify ! ( otherData
                ) ));
}
impl Clone for TPM20_NV_UndefineSpace_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_UndefineSpaceSpecial_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_UndefineSpaceSpecial_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_UndefineSpaceSpecial_Out>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( TPM20_NV_UndefineSpaceSpecial_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_UndefineSpaceSpecial_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                TPM20_NV_UndefineSpaceSpecial_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpaceSpecial_Out ) ) .
                tag as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpaceSpecial_Out ) , "::" , stringify ! ( tag
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpaceSpecial_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpaceSpecial_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpaceSpecial_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpaceSpecial_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_UndefineSpaceSpecial_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_UndefineSpaceSpecial_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_NV_UndefineSpaceSpecial_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_Write_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_Write_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_Write_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_NV_Write_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_Write_Out>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( TPM20_NV_Write_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Write_Out ) ) . tag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Write_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Write_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Write_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Write_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Write_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Write_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Write_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_Write_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_Increment_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_Increment_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_Increment_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_NV_Increment_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_Increment_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_Increment_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Increment_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Increment_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Increment_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Increment_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Increment_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Increment_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Increment_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Increment_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_Increment_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_Extend_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_Extend_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_Extend_Out>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( TPM20_NV_Extend_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_Extend_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_Extend_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Extend_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Extend_Out ) ,
                "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Extend_Out ) ) . responseSize as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Extend_Out ) ,
                "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Extend_Out ) ) . responseCode as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Extend_Out ) ,
                "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_Extend_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_Extend_Out ) ,
                "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_Extend_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_SetBits_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_SetBits_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_SetBits_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_NV_SetBits_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_SetBits_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_SetBits_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_SetBits_Out ) ) . tag as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_SetBits_Out )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_SetBits_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_SetBits_Out )
                , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_SetBits_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_SetBits_Out )
                , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_SetBits_Out ) ) . otherData as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_SetBits_Out )
                , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_SetBits_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_WriteLock_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_WriteLock_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_WriteLock_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_NV_WriteLock_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_WriteLock_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_WriteLock_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_WriteLock_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_WriteLock_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_WriteLock_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_WriteLock_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_WriteLock_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_WriteLock_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_WriteLock_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_WriteLock_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_WriteLock_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_GlobalWriteLock_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_GlobalWriteLock_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_GlobalWriteLock_Out>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( TPM20_NV_GlobalWriteLock_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_GlobalWriteLock_Out>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_GlobalWriteLock_Out )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_GlobalWriteLock_Out ) ) . tag as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_GlobalWriteLock_Out ) , "::" , stringify ! ( tag )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_GlobalWriteLock_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_GlobalWriteLock_Out ) , "::" , stringify ! (
                responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_GlobalWriteLock_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_GlobalWriteLock_Out ) , "::" , stringify ! (
                responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_GlobalWriteLock_Out ) ) .
                otherData as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                TPM20_NV_GlobalWriteLock_Out ) , "::" , stringify ! (
                otherData ) ));
}
impl Clone for TPM20_NV_GlobalWriteLock_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_ReadLock_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_ReadLock_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_ReadLock_Out>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( TPM20_NV_ReadLock_Out )
               ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_ReadLock_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_ReadLock_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ReadLock_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ReadLock_Out )
                , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ReadLock_Out ) ) . responseSize
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ReadLock_Out )
                , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ReadLock_Out ) ) . responseCode
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ReadLock_Out )
                , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ReadLock_Out ) ) . otherData as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ReadLock_Out )
                , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_ReadLock_Out {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct TPM20_NV_ChangeAuth_Out {
    pub tag: TPM_ST,
    pub responseSize: UINT32,
    pub responseCode: UINT32,
    pub otherData: UINT8,
}
#[test]
fn bindgen_test_layout_TPM20_NV_ChangeAuth_Out() {
    assert_eq!(::std::mem::size_of::<TPM20_NV_ChangeAuth_Out>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( TPM20_NV_ChangeAuth_Out ) ));
    assert_eq! (::std::mem::align_of::<TPM20_NV_ChangeAuth_Out>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( TPM20_NV_ChangeAuth_Out ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ChangeAuth_Out ) ) . tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ChangeAuth_Out
                ) , "::" , stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ChangeAuth_Out ) ) .
                responseSize as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ChangeAuth_Out
                ) , "::" , stringify ! ( responseSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ChangeAuth_Out ) ) .
                responseCode as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ChangeAuth_Out
                ) , "::" , stringify ! ( responseCode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TPM20_NV_ChangeAuth_Out ) ) . otherData
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( TPM20_NV_ChangeAuth_Out
                ) , "::" , stringify ! ( otherData ) ));
}
impl Clone for TPM20_NV_ChangeAuth_Out {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn Tss2_Sys_Startup_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                    startupType: TPM_SU) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Startup(sysContext: *mut TSS2_SYS_CONTEXT,
                            startupType: TPM_SU) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Shutdown_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     shutdownType: TPM_SU) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Shutdown(sysContext: *mut TSS2_SYS_CONTEXT,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             shutdownType: TPM_SU,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SelfTest_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     fullTest: TPMI_YES_NO) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SelfTest(sysContext: *mut TSS2_SYS_CONTEXT,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             fullTest: TPMI_YES_NO,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest_Prepare(sysContext:
                                                    *mut TSS2_SYS_CONTEXT,
                                                toTest: *mut TPML_ALG)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest_Complete(sysContext:
                                                     *mut TSS2_SYS_CONTEXT,
                                                 toDoList: *mut TPML_ALG)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_IncrementalSelfTest(sysContext: *mut TSS2_SYS_CONTEXT,
                                        cmdAuthsArray:
                                            *const TSS2_SYS_CMD_AUTHS,
                                        toTest: *mut TPML_ALG,
                                        toDoList: *mut TPML_ALG,
                                        rspAuthsArray:
                                            *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult_Prepare(sysContext: *mut TSS2_SYS_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                           outData: *mut TPM2B_MAX_BUFFER,
                                           testResult: *mut TPM_RC) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTestResult(sysContext: *mut TSS2_SYS_CONTEXT,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  outData: *mut TPM2B_MAX_BUFFER,
                                  testResult: *mut TPM_RC,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             tpmKey: TPMI_DH_OBJECT,
                                             bind: TPMI_DH_ENTITY,
                                             nonceCaller: *mut TPM2B_NONCE,
                                             encryptedSalt:
                                                 *mut TPM2B_ENCRYPTED_SECRET,
                                             sessionType: TPM_SE,
                                             symmetric: *mut TPMT_SYM_DEF,
                                             authHash: TPMI_ALG_HASH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession_Complete(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              sessionHandle:
                                                  *mut TPMI_SH_AUTH_SESSION,
                                              nonceTPM: *mut TPM2B_NONCE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_StartAuthSession(sysContext: *mut TSS2_SYS_CONTEXT,
                                     tpmKey: TPMI_DH_OBJECT,
                                     bind: TPMI_DH_ENTITY,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     nonceCaller: *mut TPM2B_NONCE,
                                     encryptedSalt:
                                         *mut TPM2B_ENCRYPTED_SECRET,
                                     sessionType: TPM_SE,
                                     symmetric: *mut TPMT_SYM_DEF,
                                     authHash: TPMI_ALG_HASH,
                                     sessionHandle: *mut TPMI_SH_AUTH_SESSION,
                                     nonceTPM: *mut TPM2B_NONCE,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyRestart_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                          sessionHandle: TPMI_SH_POLICY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyRestart(sysContext: *mut TSS2_SYS_CONTEXT,
                                  sessionHandle: TPMI_SH_POLICY,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                   parentHandle: TPMI_DH_OBJECT,
                                   inSensitive: *mut TPM2B_SENSITIVE_CREATE,
                                   inPublic: *mut TPM2B_PUBLIC,
                                   outsideInfo: *mut TPM2B_DATA,
                                   creationPCR: *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                    outPrivate: *mut TPM2B_PRIVATE,
                                    outPublic: *mut TPM2B_PUBLIC,
                                    creationData: *mut TPM2B_CREATION_DATA,
                                    creationHash: *mut TPM2B_DIGEST,
                                    creationTicket: *mut TPMT_TK_CREATION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Create(sysContext: *mut TSS2_SYS_CONTEXT,
                           parentHandle: TPMI_DH_OBJECT,
                           cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                           inSensitive: *mut TPM2B_SENSITIVE_CREATE,
                           inPublic: *mut TPM2B_PUBLIC,
                           outsideInfo: *mut TPM2B_DATA,
                           creationPCR: *mut TPML_PCR_SELECTION,
                           outPrivate: *mut TPM2B_PRIVATE,
                           outPublic: *mut TPM2B_PUBLIC,
                           creationData: *mut TPM2B_CREATION_DATA,
                           creationHash: *mut TPM2B_DIGEST,
                           creationTicket: *mut TPMT_TK_CREATION,
                           rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                 parentHandle: TPMI_DH_OBJECT,
                                 inPrivate: *mut TPM2B_PRIVATE,
                                 inPublic: *mut TPM2B_PUBLIC) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                  objectHandle: *mut TPM_HANDLE,
                                  name: *mut TPM2B_NAME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Load(sysContext: *mut TSS2_SYS_CONTEXT,
                         parentHandle: TPMI_DH_OBJECT,
                         cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                         inPrivate: *mut TPM2B_PRIVATE,
                         inPublic: *mut TPM2B_PUBLIC,
                         objectHandle: *mut TPM_HANDLE, name: *mut TPM2B_NAME,
                         rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         inPrivate: *mut TPM2B_SENSITIVE,
                                         inPublic: *mut TPM2B_PUBLIC,
                                         hierarchy: TPMI_RH_HIERARCHY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          objectHandle: *mut TPM_HANDLE,
                                          name: *mut TPM2B_NAME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_LoadExternal(sysContext: *mut TSS2_SYS_CONTEXT,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 inPrivate: *mut TPM2B_SENSITIVE,
                                 inPublic: *mut TPM2B_PUBLIC,
                                 hierarchy: TPMI_RH_HIERARCHY,
                                 objectHandle: *mut TPM_HANDLE,
                                 name: *mut TPM2B_NAME,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       objectHandle: TPMI_DH_OBJECT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                        outPublic: *mut TPM2B_PUBLIC,
                                        name: *mut TPM2B_NAME,
                                        qualifiedName: *mut TPM2B_NAME)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadPublic(sysContext: *mut TSS2_SYS_CONTEXT,
                               objectHandle: TPMI_DH_OBJECT,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               outPublic: *mut TPM2B_PUBLIC,
                               name: *mut TPM2B_NAME,
                               qualifiedName: *mut TPM2B_NAME,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential_Prepare(sysContext:
                                                   *mut TSS2_SYS_CONTEXT,
                                               activateHandle: TPMI_DH_OBJECT,
                                               keyHandle: TPMI_DH_OBJECT,
                                               credentialBlob:
                                                   *mut TPM2B_ID_OBJECT,
                                               secret:
                                                   *mut TPM2B_ENCRYPTED_SECRET)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential_Complete(sysContext:
                                                    *mut TSS2_SYS_CONTEXT,
                                                certInfo: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ActivateCredential(sysContext: *mut TSS2_SYS_CONTEXT,
                                       activateHandle: TPMI_DH_OBJECT,
                                       keyHandle: TPMI_DH_OBJECT,
                                       cmdAuthsArray:
                                           *const TSS2_SYS_CMD_AUTHS,
                                       credentialBlob: *mut TPM2B_ID_OBJECT,
                                       secret: *mut TPM2B_ENCRYPTED_SECRET,
                                       certInfo: *mut TPM2B_DIGEST,
                                       rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           handle: TPMI_DH_OBJECT,
                                           credential: *mut TPM2B_DIGEST,
                                           objectName: *mut TPM2B_NAME)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                            credentialBlob:
                                                *mut TPM2B_ID_OBJECT,
                                            secret:
                                                *mut TPM2B_ENCRYPTED_SECRET)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_MakeCredential(sysContext: *mut TSS2_SYS_CONTEXT,
                                   handle: TPMI_DH_OBJECT,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   credential: *mut TPM2B_DIGEST,
                                   objectName: *mut TPM2B_NAME,
                                   credentialBlob: *mut TPM2B_ID_OBJECT,
                                   secret: *mut TPM2B_ENCRYPTED_SECRET,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                   itemHandle: TPMI_DH_OBJECT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                    outData: *mut TPM2B_SENSITIVE_DATA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Unseal(sysContext: *mut TSS2_SYS_CONTEXT,
                           itemHandle: TPMI_DH_OBJECT,
                           cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                           outData: *mut TPM2B_SENSITIVE_DATA,
                           rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             objectHandle: TPMI_DH_OBJECT,
                                             parentHandle: TPMI_DH_OBJECT,
                                             newAuth: *mut TPM2B_AUTH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth_Complete(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              outPrivate: *mut TPM2B_PRIVATE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ObjectChangeAuth(sysContext: *mut TSS2_SYS_CONTEXT,
                                     objectHandle: TPMI_DH_OBJECT,
                                     parentHandle: TPMI_DH_OBJECT,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     newAuth: *mut TPM2B_AUTH,
                                     outPrivate: *mut TPM2B_PRIVATE,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      objectHandle: TPMI_DH_OBJECT,
                                      newParentHandle: TPMI_DH_OBJECT,
                                      encryptionKeyIn: *mut TPM2B_DATA,
                                      symmetricAlg: *mut TPMT_SYM_DEF_OBJECT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                       encryptionKeyOut: *mut TPM2B_DATA,
                                       duplicate: *mut TPM2B_PRIVATE,
                                       outSymSeed:
                                           *mut TPM2B_ENCRYPTED_SECRET)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Duplicate(sysContext: *mut TSS2_SYS_CONTEXT,
                              objectHandle: TPMI_DH_OBJECT,
                              newParentHandle: TPMI_DH_OBJECT,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              encryptionKeyIn: *mut TPM2B_DATA,
                              symmetricAlg: *mut TPMT_SYM_DEF_OBJECT,
                              encryptionKeyOut: *mut TPM2B_DATA,
                              duplicate: *mut TPM2B_PRIVATE,
                              outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                   oldParent: TPMI_DH_OBJECT,
                                   newParent: TPMI_DH_OBJECT,
                                   inDuplicate: *mut TPM2B_PRIVATE,
                                   name: *mut TPM2B_NAME,
                                   inSymSeed: *mut TPM2B_ENCRYPTED_SECRET)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                    outDuplicate: *mut TPM2B_PRIVATE,
                                    outSymSeed: *mut TPM2B_ENCRYPTED_SECRET)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Rewrap(sysContext: *mut TSS2_SYS_CONTEXT,
                           oldParent: TPMI_DH_OBJECT,
                           newParent: TPMI_DH_OBJECT,
                           cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                           inDuplicate: *mut TPM2B_PRIVATE,
                           name: *mut TPM2B_NAME,
                           inSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
                           outDuplicate: *mut TPM2B_PRIVATE,
                           outSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
                           rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                   parentHandle: TPMI_DH_OBJECT,
                                   encryptionKey: *mut TPM2B_DATA,
                                   objectPublic: *mut TPM2B_PUBLIC,
                                   duplicate: *mut TPM2B_PRIVATE,
                                   inSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
                                   symmetricAlg: *mut TPMT_SYM_DEF_OBJECT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                    outPrivate: *mut TPM2B_PRIVATE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Import(sysContext: *mut TSS2_SYS_CONTEXT,
                           parentHandle: TPMI_DH_OBJECT,
                           cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                           encryptionKey: *mut TPM2B_DATA,
                           objectPublic: *mut TPM2B_PUBLIC,
                           duplicate: *mut TPM2B_PRIVATE,
                           inSymSeed: *mut TPM2B_ENCRYPTED_SECRET,
                           symmetricAlg: *mut TPMT_SYM_DEF_OBJECT,
                           outPrivate: *mut TPM2B_PRIVATE,
                           rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        keyHandle: TPMI_DH_OBJECT,
                                        message: *mut TPM2B_PUBLIC_KEY_RSA,
                                        inScheme: *mut TPMT_RSA_DECRYPT,
                                        label: *mut TPM2B_DATA) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         outData: *mut TPM2B_PUBLIC_KEY_RSA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Encrypt(sysContext: *mut TSS2_SYS_CONTEXT,
                                keyHandle: TPMI_DH_OBJECT,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                message: *mut TPM2B_PUBLIC_KEY_RSA,
                                inScheme: *mut TPMT_RSA_DECRYPT,
                                label: *mut TPM2B_DATA,
                                outData: *mut TPM2B_PUBLIC_KEY_RSA,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        keyHandle: TPMI_DH_OBJECT,
                                        cipherText: *mut TPM2B_PUBLIC_KEY_RSA,
                                        inScheme: *mut TPMT_RSA_DECRYPT,
                                        label: *mut TPM2B_DATA) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         message: *mut TPM2B_PUBLIC_KEY_RSA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_RSA_Decrypt(sysContext: *mut TSS2_SYS_CONTEXT,
                                keyHandle: TPMI_DH_OBJECT,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                cipherText: *mut TPM2B_PUBLIC_KEY_RSA,
                                inScheme: *mut TPMT_RSA_DECRYPT,
                                label: *mut TPM2B_DATA,
                                message: *mut TPM2B_PUBLIC_KEY_RSA,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        keyHandle: TPMI_DH_OBJECT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         zPoint: *mut TPM2B_ECC_POINT,
                                         pubPoint: *mut TPM2B_ECC_POINT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_KeyGen(sysContext: *mut TSS2_SYS_CONTEXT,
                                keyHandle: TPMI_DH_OBJECT,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                zPoint: *mut TPM2B_ECC_POINT,
                                pubPoint: *mut TPM2B_ECC_POINT,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      keyHandle: TPMI_DH_OBJECT,
                                      inPoint: *mut TPM2B_ECC_POINT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                       outPoint: *mut TPM2B_ECC_POINT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECDH_ZGen(sysContext: *mut TSS2_SYS_CONTEXT,
                              keyHandle: TPMI_DH_OBJECT,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              inPoint: *mut TPM2B_ECC_POINT,
                              outPoint: *mut TPM2B_ECC_POINT,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           curveID: TPMI_ECC_CURVE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                            parameters:
                                                *mut TPMS_ALGORITHM_DETAIL_ECC)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ECC_Parameters(sysContext: *mut TSS2_SYS_CONTEXT,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   curveID: TPMI_ECC_CURVE,
                                   parameters: *mut TPMS_ALGORITHM_DETAIL_ECC,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        keyA: TPMI_DH_OBJECT,
                                        inQsB: *mut TPM2B_ECC_POINT,
                                        inQeB: *mut TPM2B_ECC_POINT,
                                        inScheme: TPMI_ECC_KEY_EXCHANGE,
                                        counter: UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         outZ1: *mut TPM2B_ECC_POINT,
                                         outZ2: *mut TPM2B_ECC_POINT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ZGen_2Phase(sysContext: *mut TSS2_SYS_CONTEXT,
                                keyA: TPMI_DH_OBJECT,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                inQsB: *mut TPM2B_ECC_POINT,
                                inQeB: *mut TPM2B_ECC_POINT,
                                inScheme: TPMI_ECC_KEY_EXCHANGE,
                                counter: UINT16, outZ1: *mut TPM2B_ECC_POINT,
                                outZ2: *mut TPM2B_ECC_POINT,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           keyHandle: TPMI_DH_OBJECT,
                                           decrypt: TPMI_YES_NO,
                                           mode: TPMI_ALG_SYM_MODE,
                                           ivIn: *mut TPM2B_IV,
                                           inData: *mut TPM2B_MAX_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                            outData: *mut TPM2B_MAX_BUFFER,
                                            ivOut: *mut TPM2B_IV) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EncryptDecrypt(sysContext: *mut TSS2_SYS_CONTEXT,
                                   keyHandle: TPMI_DH_OBJECT,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   decrypt: TPMI_YES_NO,
                                   mode: TPMI_ALG_SYM_MODE,
                                   ivIn: *mut TPM2B_IV,
                                   inData: *mut TPM2B_MAX_BUFFER,
                                   outData: *mut TPM2B_MAX_BUFFER,
                                   ivOut: *mut TPM2B_IV,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                 data: *mut TPM2B_MAX_BUFFER,
                                 hashAlg: TPMI_ALG_HASH,
                                 hierarchy: TPMI_RH_HIERARCHY) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                  outHash: *mut TPM2B_DIGEST,
                                  validation: *mut TPMT_TK_HASHCHECK)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Hash(sysContext: *mut TSS2_SYS_CONTEXT,
                         cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                         data: *mut TPM2B_MAX_BUFFER, hashAlg: TPMI_ALG_HASH,
                         hierarchy: TPMI_RH_HIERARCHY,
                         outHash: *mut TPM2B_DIGEST,
                         validation: *mut TPMT_TK_HASHCHECK,
                         rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                 handle: TPMI_DH_OBJECT,
                                 buffer: *mut TPM2B_MAX_BUFFER,
                                 hashAlg: TPMI_ALG_HASH) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                  outHMAC: *mut TPM2B_DIGEST) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC(sysContext: *mut TSS2_SYS_CONTEXT,
                         handle: TPMI_DH_OBJECT,
                         cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                         buffer: *mut TPM2B_MAX_BUFFER,
                         hashAlg: TPMI_ALG_HASH, outHMAC: *mut TPM2B_DIGEST,
                         rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      bytesRequested: UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                       randomBytes: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetRandom(sysContext: *mut TSS2_SYS_CONTEXT,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              bytesRequested: UINT16,
                              randomBytes: *mut TPM2B_DIGEST,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_StirRandom_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       inData: *mut TPM2B_SENSITIVE_DATA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_StirRandom(sysContext: *mut TSS2_SYS_CONTEXT,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               inData: *mut TPM2B_SENSITIVE_DATA,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       handle: TPMI_DH_OBJECT,
                                       auth: *mut TPM2B_AUTH,
                                       hashAlg: TPMI_ALG_HASH) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                        sequenceHandle: *mut TPMI_DH_OBJECT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HMAC_Start(sysContext: *mut TSS2_SYS_CONTEXT,
                               handle: TPMI_DH_OBJECT,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               auth: *mut TPM2B_AUTH, hashAlg: TPMI_ALG_HASH,
                               sequenceHandle: *mut TPMI_DH_OBJECT,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart_Prepare(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              auth: *mut TPM2B_AUTH,
                                              hashAlg: TPMI_ALG_HASH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart_Complete(sysContext:
                                                   *mut TSS2_SYS_CONTEXT,
                                               sequenceHandle:
                                                   *mut TPMI_DH_OBJECT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HashSequenceStart(sysContext: *mut TSS2_SYS_CONTEXT,
                                      cmdAuthsArray:
                                          *const TSS2_SYS_CMD_AUTHS,
                                      auth: *mut TPM2B_AUTH,
                                      hashAlg: TPMI_ALG_HASH,
                                      sequenceHandle: *mut TPMI_DH_OBJECT,
                                      rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceUpdate_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           sequenceHandle: TPMI_DH_OBJECT,
                                           buffer: *mut TPM2B_MAX_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceUpdate(sysContext: *mut TSS2_SYS_CONTEXT,
                                   sequenceHandle: TPMI_DH_OBJECT,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   buffer: *mut TPM2B_MAX_BUFFER,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             sequenceHandle: TPMI_DH_OBJECT,
                                             buffer: *mut TPM2B_MAX_BUFFER,
                                             hierarchy: TPMI_RH_HIERARCHY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete_Complete(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              result: *mut TPM2B_DIGEST,
                                              validation:
                                                  *mut TPMT_TK_HASHCHECK)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SequenceComplete(sysContext: *mut TSS2_SYS_CONTEXT,
                                     sequenceHandle: TPMI_DH_OBJECT,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     buffer: *mut TPM2B_MAX_BUFFER,
                                     hierarchy: TPMI_RH_HIERARCHY,
                                     result: *mut TPM2B_DIGEST,
                                     validation: *mut TPMT_TK_HASHCHECK,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete_Prepare(sysContext:
                                                      *mut TSS2_SYS_CONTEXT,
                                                  pcrHandle: TPMI_DH_PCR,
                                                  sequenceHandle:
                                                      TPMI_DH_OBJECT,
                                                  buffer:
                                                      *mut TPM2B_MAX_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete_Complete(sysContext:
                                                       *mut TSS2_SYS_CONTEXT,
                                                   results:
                                                       *mut TPML_DIGEST_VALUES)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EventSequenceComplete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          pcrHandle: TPMI_DH_PCR,
                                          sequenceHandle: TPMI_DH_OBJECT,
                                          cmdAuthsArray:
                                              *const TSS2_SYS_CMD_AUTHS,
                                          buffer: *mut TPM2B_MAX_BUFFER,
                                          results: *mut TPML_DIGEST_VALUES,
                                          rspAuthsArray:
                                              *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                    objectHandle: TPMI_DH_OBJECT,
                                    signHandle: TPMI_DH_OBJECT,
                                    qualifyingData: *mut TPM2B_DATA,
                                    inScheme: *mut TPMT_SIG_SCHEME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                     certifyInfo: *mut TPM2B_ATTEST,
                                     signature: *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Certify(sysContext: *mut TSS2_SYS_CONTEXT,
                            objectHandle: TPMI_DH_OBJECT,
                            signHandle: TPMI_DH_OBJECT,
                            cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                            qualifyingData: *mut TPM2B_DATA,
                            inScheme: *mut TPMT_SIG_SCHEME,
                            certifyInfo: *mut TPM2B_ATTEST,
                            signature: *mut TPMT_SIGNATURE,
                            rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            signHandle: TPMI_DH_OBJECT,
                                            objectHandle: TPMI_DH_OBJECT,
                                            qualifyingData: *mut TPM2B_DATA,
                                            creationHash: *mut TPM2B_DIGEST,
                                            inScheme: *mut TPMT_SIG_SCHEME,
                                            creationTicket:
                                                *mut TPMT_TK_CREATION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation_Complete(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             certifyInfo: *mut TPM2B_ATTEST,
                                             signature: *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CertifyCreation(sysContext: *mut TSS2_SYS_CONTEXT,
                                    signHandle: TPMI_DH_OBJECT,
                                    objectHandle: TPMI_DH_OBJECT,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    qualifyingData: *mut TPM2B_DATA,
                                    creationHash: *mut TPM2B_DIGEST,
                                    inScheme: *mut TPMT_SIG_SCHEME,
                                    creationTicket: *mut TPMT_TK_CREATION,
                                    certifyInfo: *mut TPM2B_ATTEST,
                                    signature: *mut TPMT_SIGNATURE,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                  signHandle: TPMI_DH_OBJECT,
                                  qualifyingData: *mut TPM2B_DATA,
                                  inScheme: *mut TPMT_SIG_SCHEME,
                                  PCRselect: *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                   quoted: *mut TPM2B_ATTEST,
                                   signature: *mut TPMT_SIGNATURE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Quote(sysContext: *mut TSS2_SYS_CONTEXT,
                          signHandle: TPMI_DH_OBJECT,
                          cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                          qualifyingData: *mut TPM2B_DATA,
                          inScheme: *mut TPMT_SIG_SCHEME,
                          PCRselect: *mut TPML_PCR_SELECTION,
                          quoted: *mut TPM2B_ATTEST,
                          signature: *mut TPMT_SIGNATURE,
                          rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest_Prepare(sysContext:
                                                      *mut TSS2_SYS_CONTEXT,
                                                  privacyAdminHandle:
                                                      TPMI_RH_ENDORSEMENT,
                                                  signHandle: TPMI_DH_OBJECT,
                                                  sessionHandle: TPMI_SH_HMAC,
                                                  qualifyingData:
                                                      *mut TPM2B_DATA,
                                                  inScheme:
                                                      *mut TPMT_SIG_SCHEME)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest_Complete(sysContext:
                                                       *mut TSS2_SYS_CONTEXT,
                                                   auditInfo:
                                                       *mut TPM2B_ATTEST,
                                                   signature:
                                                       *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetSessionAuditDigest(sysContext: *mut TSS2_SYS_CONTEXT,
                                          privacyAdminHandle:
                                              TPMI_RH_ENDORSEMENT,
                                          signHandle: TPMI_DH_OBJECT,
                                          sessionHandle: TPMI_SH_HMAC,
                                          cmdAuthsArray:
                                              *const TSS2_SYS_CMD_AUTHS,
                                          qualifyingData: *mut TPM2B_DATA,
                                          inScheme: *mut TPMT_SIG_SCHEME,
                                          auditInfo: *mut TPM2B_ATTEST,
                                          signature: *mut TPMT_SIGNATURE,
                                          rspAuthsArray:
                                              *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest_Prepare(sysContext:
                                                      *mut TSS2_SYS_CONTEXT,
                                                  privacyHandle:
                                                      TPMI_RH_ENDORSEMENT,
                                                  signHandle: TPMI_DH_OBJECT,
                                                  qualifyingData:
                                                      *mut TPM2B_DATA,
                                                  inScheme:
                                                      *mut TPMT_SIG_SCHEME)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest_Complete(sysContext:
                                                       *mut TSS2_SYS_CONTEXT,
                                                   auditInfo:
                                                       *mut TPM2B_ATTEST,
                                                   signature:
                                                       *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCommandAuditDigest(sysContext: *mut TSS2_SYS_CONTEXT,
                                          privacyHandle: TPMI_RH_ENDORSEMENT,
                                          signHandle: TPMI_DH_OBJECT,
                                          cmdAuthsArray:
                                              *const TSS2_SYS_CMD_AUTHS,
                                          qualifyingData: *mut TPM2B_DATA,
                                          inScheme: *mut TPMT_SIG_SCHEME,
                                          auditInfo: *mut TPM2B_ATTEST,
                                          signature: *mut TPMT_SIGNATURE,
                                          rspAuthsArray:
                                              *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                    privacyAdminHandle: TPMI_RH_ENDORSEMENT,
                                    signHandle: TPMI_DH_OBJECT,
                                    qualifyingData: *mut TPM2B_DATA,
                                    inScheme: *mut TPMT_SIG_SCHEME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                     timeInfo: *mut TPM2B_ATTEST,
                                     signature: *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetTime(sysContext: *mut TSS2_SYS_CONTEXT,
                            privacyAdminHandle: TPMI_RH_ENDORSEMENT,
                            signHandle: TPMI_DH_OBJECT,
                            cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                            qualifyingData: *mut TPM2B_DATA,
                            inScheme: *mut TPMT_SIG_SCHEME,
                            timeInfo: *mut TPM2B_ATTEST,
                            signature: *mut TPMT_SIGNATURE,
                            rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                   signHandle: TPMI_DH_OBJECT,
                                   P1: *mut TPM2B_ECC_POINT,
                                   s2: *mut TPM2B_SENSITIVE_DATA,
                                   y2: *mut TPM2B_ECC_PARAMETER) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                    K: *mut TPM2B_ECC_POINT,
                                    L: *mut TPM2B_ECC_POINT,
                                    E: *mut TPM2B_ECC_POINT,
                                    counter: *mut UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Commit(sysContext: *mut TSS2_SYS_CONTEXT,
                           signHandle: TPMI_DH_OBJECT,
                           cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                           P1: *mut TPM2B_ECC_POINT,
                           s2: *mut TPM2B_SENSITIVE_DATA,
                           y2: *mut TPM2B_ECC_PARAMETER,
                           K: *mut TPM2B_ECC_POINT, L: *mut TPM2B_ECC_POINT,
                           E: *mut TPM2B_ECC_POINT, counter: *mut UINT16,
                           rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         curveID: TPMI_ECC_CURVE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          Q: *mut TPM2B_ECC_POINT,
                                          counter: *mut UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EC_Ephemeral(sysContext: *mut TSS2_SYS_CONTEXT,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 curveID: TPMI_ECC_CURVE,
                                 Q: *mut TPM2B_ECC_POINT,
                                 counter: *mut UINT16,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            keyHandle: TPMI_DH_OBJECT,
                                            digest: *mut TPM2B_DIGEST,
                                            signature: *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature_Complete(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             validation:
                                                 *mut TPMT_TK_VERIFIED)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_VerifySignature(sysContext: *mut TSS2_SYS_CONTEXT,
                                    keyHandle: TPMI_DH_OBJECT,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    digest: *mut TPM2B_DIGEST,
                                    signature: *mut TPMT_SIGNATURE,
                                    validation: *mut TPMT_TK_VERIFIED,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                 keyHandle: TPMI_DH_OBJECT,
                                 digest: *mut TPM2B_DIGEST,
                                 inScheme: *mut TPMT_SIG_SCHEME,
                                 validation: *mut TPMT_TK_HASHCHECK)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                  signature: *mut TPMT_SIGNATURE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Sign(sysContext: *mut TSS2_SYS_CONTEXT,
                         keyHandle: TPMI_DH_OBJECT,
                         cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                         digest: *mut TPM2B_DIGEST,
                         inScheme: *mut TPMT_SIG_SCHEME,
                         validation: *mut TPMT_TK_HASHCHECK,
                         signature: *mut TPMT_SIGNATURE,
                         rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCommandCodeAuditStatus_Prepare(sysContext:
                                                          *mut TSS2_SYS_CONTEXT,
                                                      auth: TPMI_RH_PROVISION,
                                                      auditAlg: TPMI_ALG_HASH,
                                                      setList: *mut TPML_CC,
                                                      clearList: *mut TPML_CC)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetCommandCodeAuditStatus(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              auth: TPMI_RH_PROVISION,
                                              cmdAuthsArray:
                                                  *const TSS2_SYS_CMD_AUTHS,
                                              auditAlg: TPMI_ALG_HASH,
                                              setList: *mut TPML_CC,
                                              clearList: *mut TPML_CC,
                                              rspAuthsArray:
                                                  *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Extend_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       pcrHandle: TPMI_DH_PCR,
                                       digests: *mut TPML_DIGEST_VALUES)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Extend(sysContext: *mut TSS2_SYS_CONTEXT,
                               pcrHandle: TPMI_DH_PCR,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               digests: *mut TPML_DIGEST_VALUES,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      pcrHandle: TPMI_DH_PCR,
                                      eventData: *mut TPM2B_EVENT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                       digests: *mut TPML_DIGEST_VALUES)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Event(sysContext: *mut TSS2_SYS_CONTEXT,
                              pcrHandle: TPMI_DH_PCR,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              eventData: *mut TPM2B_EVENT,
                              digests: *mut TPML_DIGEST_VALUES,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     pcrSelectionIn: *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                      pcrUpdateCounter: *mut UINT32,
                                      pcrSelectionOut:
                                          *mut TPML_PCR_SELECTION,
                                      pcrValues: *mut TPML_DIGEST) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Read(sysContext: *mut TSS2_SYS_CONTEXT,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             pcrSelectionIn: *mut TPML_PCR_SELECTION,
                             pcrUpdateCounter: *mut UINT32,
                             pcrSelectionOut: *mut TPML_PCR_SELECTION,
                             pcrValues: *mut TPML_DIGEST,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         authHandle: TPMI_RH_PLATFORM,
                                         pcrAllocation:
                                             *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          allocationSuccess: *mut TPMI_YES_NO,
                                          maxPCR: *mut UINT32,
                                          sizeNeeded: *mut UINT32,
                                          sizeAvailable: *mut UINT32)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Allocate(sysContext: *mut TSS2_SYS_CONTEXT,
                                 authHandle: TPMI_RH_PLATFORM,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 pcrAllocation: *mut TPML_PCR_SELECTION,
                                 allocationSuccess: *mut TPMI_YES_NO,
                                 maxPCR: *mut UINT32, sizeNeeded: *mut UINT32,
                                 sizeAvailable: *mut UINT32,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthPolicy_Prepare(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              authHandle: TPMI_RH_PLATFORM,
                                              authPolicy: *mut TPM2B_DIGEST,
                                              hashAlg: TPMI_ALG_HASH,
                                              pcrNum: TPMI_DH_PCR) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthPolicy(sysContext: *mut TSS2_SYS_CONTEXT,
                                      authHandle: TPMI_RH_PLATFORM,
                                      cmdAuthsArray:
                                          *const TSS2_SYS_CMD_AUTHS,
                                      authPolicy: *mut TPM2B_DIGEST,
                                      hashAlg: TPMI_ALG_HASH,
                                      pcrNum: TPMI_DH_PCR,
                                      rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthValue_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             pcrHandle: TPMI_DH_PCR,
                                             auth: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_SetAuthValue(sysContext: *mut TSS2_SYS_CONTEXT,
                                     pcrHandle: TPMI_DH_PCR,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     auth: *mut TPM2B_DIGEST,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Reset_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      pcrHandle: TPMI_DH_PCR) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PCR_Reset(sysContext: *mut TSS2_SYS_CONTEXT,
                              pcrHandle: TPMI_DH_PCR,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         authObject: TPMI_DH_OBJECT,
                                         policySession: TPMI_SH_POLICY,
                                         nonceTPM: *mut TPM2B_NONCE,
                                         cpHashA: *mut TPM2B_DIGEST,
                                         policyRef: *mut TPM2B_NONCE,
                                         expiration: INT32,
                                         auth: *mut TPMT_SIGNATURE) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          timeout: *mut TPM2B_TIMEOUT,
                                          policyTicket: *mut TPMT_TK_AUTH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySigned(sysContext: *mut TSS2_SYS_CONTEXT,
                                 authObject: TPMI_DH_OBJECT,
                                 policySession: TPMI_SH_POLICY,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 nonceTPM: *mut TPM2B_NONCE,
                                 cpHashA: *mut TPM2B_DIGEST,
                                 policyRef: *mut TPM2B_NONCE,
                                 expiration: INT32, auth: *mut TPMT_SIGNATURE,
                                 timeout: *mut TPM2B_TIMEOUT,
                                 policyTicket: *mut TPMT_TK_AUTH,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         authHandle: TPMI_DH_ENTITY,
                                         policySession: TPMI_SH_POLICY,
                                         nonceTPM: *mut TPM2B_NONCE,
                                         cpHashA: *mut TPM2B_DIGEST,
                                         policyRef: *mut TPM2B_NONCE,
                                         expiration: INT32) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          timeout: *mut TPM2B_TIMEOUT,
                                          policyTicket: *mut TPMT_TK_AUTH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicySecret(sysContext: *mut TSS2_SYS_CONTEXT,
                                 authHandle: TPMI_DH_ENTITY,
                                 policySession: TPMI_SH_POLICY,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 nonceTPM: *mut TPM2B_NONCE,
                                 cpHashA: *mut TPM2B_DIGEST,
                                 policyRef: *mut TPM2B_NONCE,
                                 expiration: INT32,
                                 timeout: *mut TPM2B_TIMEOUT,
                                 policyTicket: *mut TPMT_TK_AUTH,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTicket_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         policySession: TPMI_SH_POLICY,
                                         timeout: *mut TPM2B_TIMEOUT,
                                         cpHashA: *mut TPM2B_DIGEST,
                                         policyRef: *mut TPM2B_NONCE,
                                         authName: *mut TPM2B_NAME,
                                         ticket: *mut TPMT_TK_AUTH) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyTicket(sysContext: *mut TSS2_SYS_CONTEXT,
                                 policySession: TPMI_SH_POLICY,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 timeout: *mut TPM2B_TIMEOUT,
                                 cpHashA: *mut TPM2B_DIGEST,
                                 policyRef: *mut TPM2B_NONCE,
                                 authName: *mut TPM2B_NAME,
                                 ticket: *mut TPMT_TK_AUTH,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyOR_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     policySession: TPMI_SH_POLICY,
                                     pHashList: *mut TPML_DIGEST) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyOR(sysContext: *mut TSS2_SYS_CONTEXT,
                             policySession: TPMI_SH_POLICY,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             pHashList: *mut TPML_DIGEST,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPCR_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      policySession: TPMI_SH_POLICY,
                                      pcrDigest: *mut TPM2B_DIGEST,
                                      pcrs: *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPCR(sysContext: *mut TSS2_SYS_CONTEXT,
                              policySession: TPMI_SH_POLICY,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              pcrDigest: *mut TPM2B_DIGEST,
                              pcrs: *mut TPML_PCR_SELECTION,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyLocality_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           policySession: TPMI_SH_POLICY,
                                           locality: TPMA_LOCALITY) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyLocality(sysContext: *mut TSS2_SYS_CONTEXT,
                                   policySession: TPMI_SH_POLICY,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   locality: TPMA_LOCALITY,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNV_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     authHandle: TPMI_RH_NV_AUTH,
                                     nvIndex: TPMI_RH_NV_INDEX,
                                     policySession: TPMI_SH_POLICY,
                                     operandB: *mut TPM2B_OPERAND,
                                     offset: UINT16, operation: TPM_EO)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNV(sysContext: *mut TSS2_SYS_CONTEXT,
                             authHandle: TPMI_RH_NV_AUTH,
                             nvIndex: TPMI_RH_NV_INDEX,
                             policySession: TPMI_SH_POLICY,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             operandB: *mut TPM2B_OPERAND, offset: UINT16,
                             operation: TPM_EO,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCounterTimer_Prepare(sysContext:
                                                   *mut TSS2_SYS_CONTEXT,
                                               policySession: TPMI_SH_POLICY,
                                               operandB: *mut TPM2B_OPERAND,
                                               offset: UINT16,
                                               operation: TPM_EO) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCounterTimer(sysContext: *mut TSS2_SYS_CONTEXT,
                                       policySession: TPMI_SH_POLICY,
                                       cmdAuthsArray:
                                           *const TSS2_SYS_CMD_AUTHS,
                                       operandB: *mut TPM2B_OPERAND,
                                       offset: UINT16, operation: TPM_EO,
                                       rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCommandCode_Prepare(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              policySession: TPMI_SH_POLICY,
                                              code: TPM_CC) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCommandCode(sysContext: *mut TSS2_SYS_CONTEXT,
                                      policySession: TPMI_SH_POLICY,
                                      cmdAuthsArray:
                                          *const TSS2_SYS_CMD_AUTHS,
                                      code: TPM_CC,
                                      rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPhysicalPresence_Prepare(sysContext:
                                                       *mut TSS2_SYS_CONTEXT,
                                                   policySession:
                                                       TPMI_SH_POLICY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPhysicalPresence(sysContext: *mut TSS2_SYS_CONTEXT,
                                           policySession: TPMI_SH_POLICY,
                                           cmdAuthsArray:
                                               *const TSS2_SYS_CMD_AUTHS,
                                           rspAuthsArray:
                                               *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCpHash_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         policySession: TPMI_SH_POLICY,
                                         cpHashA: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyCpHash(sysContext: *mut TSS2_SYS_CONTEXT,
                                 policySession: TPMI_SH_POLICY,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 cpHashA: *mut TPM2B_DIGEST,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNameHash_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           policySession: TPMI_SH_POLICY,
                                           nameHash: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNameHash(sysContext: *mut TSS2_SYS_CONTEXT,
                                   policySession: TPMI_SH_POLICY,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   nameHash: *mut TPM2B_DIGEST,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyDuplicationSelect_Prepare(sysContext:
                                                        *mut TSS2_SYS_CONTEXT,
                                                    policySession:
                                                        TPMI_SH_POLICY,
                                                    objectName:
                                                        *mut TPM2B_NAME,
                                                    newParentName:
                                                        *mut TPM2B_NAME,
                                                    includeObject:
                                                        TPMI_YES_NO)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyDuplicationSelect(sysContext: *mut TSS2_SYS_CONTEXT,
                                            policySession: TPMI_SH_POLICY,
                                            cmdAuthsArray:
                                                *const TSS2_SYS_CMD_AUTHS,
                                            objectName: *mut TPM2B_NAME,
                                            newParentName: *mut TPM2B_NAME,
                                            includeObject: TPMI_YES_NO,
                                            rspAuthsArray:
                                                *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorize_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            policySession: TPMI_SH_POLICY,
                                            approvedPolicy: *mut TPM2B_DIGEST,
                                            policyRef: *mut TPM2B_NONCE,
                                            keySign: *mut TPM2B_NAME,
                                            checkTicket:
                                                *mut TPMT_TK_VERIFIED)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthorize(sysContext: *mut TSS2_SYS_CONTEXT,
                                    policySession: TPMI_SH_POLICY,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    approvedPolicy: *mut TPM2B_DIGEST,
                                    policyRef: *mut TPM2B_NONCE,
                                    keySign: *mut TPM2B_NAME,
                                    checkTicket: *mut TPMT_TK_VERIFIED,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthValue_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            policySession: TPMI_SH_POLICY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyAuthValue(sysContext: *mut TSS2_SYS_CONTEXT,
                                    policySession: TPMI_SH_POLICY,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPassword_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           policySession: TPMI_SH_POLICY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyPassword(sysContext: *mut TSS2_SYS_CONTEXT,
                                   policySession: TPMI_SH_POLICY,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            policySession: TPMI_SH_POLICY)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest_Complete(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             policyDigest: *mut TPM2B_DIGEST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyGetDigest(sysContext: *mut TSS2_SYS_CONTEXT,
                                    policySession: TPMI_SH_POLICY,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    policyDigest: *mut TPM2B_DIGEST,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNvWritten_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            policySession: TPMI_SH_POLICY,
                                            writtenSet: TPMI_YES_NO)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PolicyNvWritten(sysContext: *mut TSS2_SYS_CONTEXT,
                                    policySession: TPMI_SH_POLICY,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    writtenSet: TPMI_YES_NO,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                          primaryHandle: TPMI_RH_HIERARCHY,
                                          inSensitive:
                                              *mut TPM2B_SENSITIVE_CREATE,
                                          inPublic: *mut TPM2B_PUBLIC,
                                          outsideInfo: *mut TPM2B_DATA,
                                          creationPCR:
                                              *mut TPML_PCR_SELECTION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                           objectHandle: *mut TPM_HANDLE,
                                           outPublic: *mut TPM2B_PUBLIC,
                                           creationData:
                                               *mut TPM2B_CREATION_DATA,
                                           creationHash: *mut TPM2B_DIGEST,
                                           creationTicket:
                                               *mut TPMT_TK_CREATION,
                                           name: *mut TPM2B_NAME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_CreatePrimary(sysContext: *mut TSS2_SYS_CONTEXT,
                                  primaryHandle: TPMI_RH_HIERARCHY,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  inSensitive: *mut TPM2B_SENSITIVE_CREATE,
                                  inPublic: *mut TPM2B_PUBLIC,
                                  outsideInfo: *mut TPM2B_DATA,
                                  creationPCR: *mut TPML_PCR_SELECTION,
                                  objectHandle: *mut TPM_HANDLE,
                                  outPublic: *mut TPM2B_PUBLIC,
                                  creationData: *mut TPM2B_CREATION_DATA,
                                  creationHash: *mut TPM2B_DIGEST,
                                  creationTicket: *mut TPMT_TK_CREATION,
                                  name: *mut TPM2B_NAME,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyControl_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             authHandle: TPMI_RH_HIERARCHY,
                                             enable: TPMI_RH_ENABLES,
                                             state: TPMI_YES_NO) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyControl(sysContext: *mut TSS2_SYS_CONTEXT,
                                     authHandle: TPMI_RH_HIERARCHY,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     enable: TPMI_RH_ENABLES,
                                     state: TPMI_YES_NO,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetPrimaryPolicy_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             authHandle:
                                                 TPMI_RH_HIERARCHY_AUTH,
                                             authPolicy: *mut TPM2B_DIGEST,
                                             hashAlg: TPMI_ALG_HASH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetPrimaryPolicy(sysContext: *mut TSS2_SYS_CONTEXT,
                                     authHandle: TPMI_RH_HIERARCHY_AUTH,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     authPolicy: *mut TPM2B_DIGEST,
                                     hashAlg: TPMI_ALG_HASH,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangePPS_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      authHandle: TPMI_RH_PLATFORM) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangePPS(sysContext: *mut TSS2_SYS_CONTEXT,
                              authHandle: TPMI_RH_PLATFORM,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangeEPS_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      authHandle: TPMI_RH_PLATFORM) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ChangeEPS(sysContext: *mut TSS2_SYS_CONTEXT,
                              authHandle: TPMI_RH_PLATFORM,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Clear_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                  authHandle: TPMI_RH_CLEAR) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Clear(sysContext: *mut TSS2_SYS_CONTEXT,
                          authHandle: TPMI_RH_CLEAR,
                          cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                          rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClearControl_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         auth: TPMI_RH_CLEAR,
                                         disable: TPMI_YES_NO) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClearControl(sysContext: *mut TSS2_SYS_CONTEXT,
                                 auth: TPMI_RH_CLEAR,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 disable: TPMI_YES_NO,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyChangeAuth_Prepare(sysContext:
                                                    *mut TSS2_SYS_CONTEXT,
                                                authHandle:
                                                    TPMI_RH_HIERARCHY_AUTH,
                                                newAuth: *mut TPM2B_AUTH)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_HierarchyChangeAuth(sysContext: *mut TSS2_SYS_CONTEXT,
                                        authHandle: TPMI_RH_HIERARCHY_AUTH,
                                        cmdAuthsArray:
                                            *const TSS2_SYS_CMD_AUTHS,
                                        newAuth: *mut TPM2B_AUTH,
                                        rspAuthsArray:
                                            *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackLockReset_Prepare(sysContext:
                                                          *mut TSS2_SYS_CONTEXT,
                                                      lockHandle:
                                                          TPMI_RH_LOCKOUT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackLockReset(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              lockHandle: TPMI_RH_LOCKOUT,
                                              cmdAuthsArray:
                                                  *const TSS2_SYS_CMD_AUTHS,
                                              rspAuthsArray:
                                                  *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackParameters_Prepare(sysContext:
                                                           *mut TSS2_SYS_CONTEXT,
                                                       lockHandle:
                                                           TPMI_RH_LOCKOUT,
                                                       newMaxTries: UINT32,
                                                       newRecoveryTime:
                                                           UINT32,
                                                       lockoutRecovery:
                                                           UINT32) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_DictionaryAttackParameters(sysContext:
                                                   *mut TSS2_SYS_CONTEXT,
                                               lockHandle: TPMI_RH_LOCKOUT,
                                               cmdAuthsArray:
                                                   *const TSS2_SYS_CMD_AUTHS,
                                               newMaxTries: UINT32,
                                               newRecoveryTime: UINT32,
                                               lockoutRecovery: UINT32,
                                               rspAuthsArray:
                                                   *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PP_Commands_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        auth: TPMI_RH_PLATFORM,
                                        setList: *mut TPML_CC,
                                        clearList: *mut TPML_CC) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_PP_Commands(sysContext: *mut TSS2_SYS_CONTEXT,
                                auth: TPMI_RH_PLATFORM,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                setList: *mut TPML_CC,
                                clearList: *mut TPML_CC,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetAlgorithmSet_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            authHandle: TPMI_RH_PLATFORM,
                                            algorithmSet: UINT32) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_SetAlgorithmSet(sysContext: *mut TSS2_SYS_CONTEXT,
                                    authHandle: TPMI_RH_PLATFORM,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    algorithmSet: UINT32,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeStart_Prepare(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              authorization: TPMI_RH_PLATFORM,
                                              keyHandle: TPMI_DH_OBJECT,
                                              fuDigest: *mut TPM2B_DIGEST,
                                              manifestSignature:
                                                  *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeStart(sysContext: *mut TSS2_SYS_CONTEXT,
                                      authorization: TPMI_RH_PLATFORM,
                                      keyHandle: TPMI_DH_OBJECT,
                                      cmdAuthsArray:
                                          *const TSS2_SYS_CMD_AUTHS,
                                      fuDigest: *mut TPM2B_DIGEST,
                                      manifestSignature: *mut TPMT_SIGNATURE,
                                      rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             fuData: *mut TPM2B_MAX_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData_Complete(sysContext:
                                                  *mut TSS2_SYS_CONTEXT,
                                              nextDigest: *mut TPMT_HA,
                                              firstDigest: *mut TPMT_HA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FieldUpgradeData(sysContext: *mut TSS2_SYS_CONTEXT,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     fuData: *mut TPM2B_MAX_BUFFER,
                                     nextDigest: *mut TPMT_HA,
                                     firstDigest: *mut TPMT_HA,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         sequenceNumber: UINT32) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                          fuData: *mut TPM2B_MAX_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FirmwareRead(sysContext: *mut TSS2_SYS_CONTEXT,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 sequenceNumber: UINT32,
                                 fuData: *mut TPM2B_MAX_BUFFER,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        saveHandle: TPMI_DH_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         context: *mut TPMS_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextSave(sysContext: *mut TSS2_SYS_CONTEXT,
                                saveHandle: TPMI_DH_CONTEXT,
                                context: *mut TPMS_CONTEXT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        context: *mut TPMS_CONTEXT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                         loadedHandle: *mut TPMI_DH_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ContextLoad(sysContext: *mut TSS2_SYS_CONTEXT,
                                context: *mut TPMS_CONTEXT,
                                loadedHandle: *mut TPMI_DH_CONTEXT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FlushContext_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         flushHandle: TPMI_DH_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_FlushContext(sysContext: *mut TSS2_SYS_CONTEXT,
                                 flushHandle: TPMI_DH_CONTEXT) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EvictControl_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         auth: TPMI_RH_PROVISION,
                                         objectHandle: TPMI_DH_OBJECT,
                                         persistentHandle: TPMI_DH_PERSISTENT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_EvictControl(sysContext: *mut TSS2_SYS_CONTEXT,
                                 auth: TPMI_RH_PROVISION,
                                 objectHandle: TPMI_DH_OBJECT,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 persistentHandle: TPMI_DH_PERSISTENT,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock_Prepare(sysContext: *mut TSS2_SYS_CONTEXT)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                       currentTime: *mut TPMS_TIME_INFO)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ReadClock(sysContext: *mut TSS2_SYS_CONTEXT,
                              currentTime: *mut TPMS_TIME_INFO) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockSet_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     auth: TPMI_RH_PROVISION, newTime: UINT64)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockSet(sysContext: *mut TSS2_SYS_CONTEXT,
                             auth: TPMI_RH_PROVISION,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             newTime: UINT64,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockRateAdjust_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            auth: TPMI_RH_PROVISION,
                                            rateAdjust: TPM_CLOCK_ADJUST)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_ClockRateAdjust(sysContext: *mut TSS2_SYS_CONTEXT,
                                    auth: TPMI_RH_PROVISION,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    rateAdjust: TPM_CLOCK_ADJUST,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                          capability: TPM_CAP,
                                          property: UINT32,
                                          propertyCount: UINT32) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                           moreData: *mut TPMI_YES_NO,
                                           capabilityData:
                                               *mut TPMS_CAPABILITY_DATA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_GetCapability(sysContext: *mut TSS2_SYS_CONTEXT,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  capability: TPM_CAP, property: UINT32,
                                  propertyCount: UINT32,
                                  moreData: *mut TPMI_YES_NO,
                                  capabilityData: *mut TPMS_CAPABILITY_DATA,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_TestParms_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      parameters: *mut TPMT_PUBLIC_PARMS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_TestParms(sysContext: *mut TSS2_SYS_CONTEXT,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              parameters: *mut TPMT_PUBLIC_PARMS,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_DefineSpace_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                           authHandle: TPMI_RH_PROVISION,
                                           auth: *mut TPM2B_AUTH,
                                           publicInfo: *mut TPM2B_NV_PUBLIC)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_DefineSpace(sysContext: *mut TSS2_SYS_CONTEXT,
                                   authHandle: TPMI_RH_PROVISION,
                                   cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                   auth: *mut TPM2B_AUTH,
                                   publicInfo: *mut TPM2B_NV_PUBLIC,
                                   rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpace_Prepare(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             authHandle: TPMI_RH_PROVISION,
                                             nvIndex: TPMI_RH_NV_INDEX)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpace(sysContext: *mut TSS2_SYS_CONTEXT,
                                     authHandle: TPMI_RH_PROVISION,
                                     nvIndex: TPMI_RH_NV_INDEX,
                                     cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                     rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpaceSpecial_Prepare(sysContext:
                                                        *mut TSS2_SYS_CONTEXT,
                                                    nvIndex: TPMI_RH_NV_INDEX,
                                                    platform:
                                                        TPMI_RH_PLATFORM)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_UndefineSpaceSpecial(sysContext: *mut TSS2_SYS_CONTEXT,
                                            nvIndex: TPMI_RH_NV_INDEX,
                                            platform: TPMI_RH_PLATFORM,
                                            cmdAuthsArray:
                                                *const TSS2_SYS_CMD_AUTHS,
                                            rspAuthsArray:
                                                *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                          nvIndex: TPMI_RH_NV_INDEX)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                           nvPublic: *mut TPM2B_NV_PUBLIC,
                                           nvName: *mut TPM2B_NAME) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadPublic(sysContext: *mut TSS2_SYS_CONTEXT,
                                  nvIndex: TPMI_RH_NV_INDEX,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  nvPublic: *mut TPM2B_NV_PUBLIC,
                                  nvName: *mut TPM2B_NAME,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Write_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                     authHandle: TPMI_RH_NV_AUTH,
                                     nvIndex: TPMI_RH_NV_INDEX,
                                     data: *mut TPM2B_MAX_NV_BUFFER,
                                     offset: UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Write(sysContext: *mut TSS2_SYS_CONTEXT,
                             authHandle: TPMI_RH_NV_AUTH,
                             nvIndex: TPMI_RH_NV_INDEX,
                             cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                             data: *mut TPM2B_MAX_NV_BUFFER, offset: UINT16,
                             rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Increment_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         authHandle: TPMI_RH_NV_AUTH,
                                         nvIndex: TPMI_RH_NV_INDEX) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Increment(sysContext: *mut TSS2_SYS_CONTEXT,
                                 authHandle: TPMI_RH_NV_AUTH,
                                 nvIndex: TPMI_RH_NV_INDEX,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Extend_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                      authHandle: TPMI_RH_NV_AUTH,
                                      nvIndex: TPMI_RH_NV_INDEX,
                                      data: *mut TPM2B_MAX_NV_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Extend(sysContext: *mut TSS2_SYS_CONTEXT,
                              authHandle: TPMI_RH_NV_AUTH,
                              nvIndex: TPMI_RH_NV_INDEX,
                              cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                              data: *mut TPM2B_MAX_NV_BUFFER,
                              rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_SetBits_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       authHandle: TPMI_RH_NV_AUTH,
                                       nvIndex: TPMI_RH_NV_INDEX,
                                       bits: UINT64) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_SetBits(sysContext: *mut TSS2_SYS_CONTEXT,
                               authHandle: TPMI_RH_NV_AUTH,
                               nvIndex: TPMI_RH_NV_INDEX,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               bits: UINT64,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_WriteLock_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                         authHandle: TPMI_RH_NV_AUTH,
                                         nvIndex: TPMI_RH_NV_INDEX) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_WriteLock(sysContext: *mut TSS2_SYS_CONTEXT,
                                 authHandle: TPMI_RH_NV_AUTH,
                                 nvIndex: TPMI_RH_NV_INDEX,
                                 cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                 rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_GlobalWriteLock_Prepare(sysContext:
                                                   *mut TSS2_SYS_CONTEXT,
                                               authHandle: TPMI_RH_PROVISION)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_GlobalWriteLock(sysContext: *mut TSS2_SYS_CONTEXT,
                                       authHandle: TPMI_RH_PROVISION,
                                       cmdAuthsArray:
                                           *const TSS2_SYS_CMD_AUTHS,
                                       rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                    authHandle: TPMI_RH_NV_AUTH,
                                    nvIndex: TPMI_RH_NV_INDEX, size: UINT16,
                                    offset: UINT16) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                     data: *mut TPM2B_MAX_NV_BUFFER)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Read(sysContext: *mut TSS2_SYS_CONTEXT,
                            authHandle: TPMI_RH_NV_AUTH,
                            nvIndex: TPMI_RH_NV_INDEX,
                            cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                            size: UINT16, offset: UINT16,
                            data: *mut TPM2B_MAX_NV_BUFFER,
                            rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadLock_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                        authHandle: TPMI_RH_NV_AUTH,
                                        nvIndex: TPMI_RH_NV_INDEX) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ReadLock(sysContext: *mut TSS2_SYS_CONTEXT,
                                authHandle: TPMI_RH_NV_AUTH,
                                nvIndex: TPMI_RH_NV_INDEX,
                                cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ChangeAuth_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                          nvIndex: TPMI_RH_NV_INDEX,
                                          newAuth: *mut TPM2B_AUTH) -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_ChangeAuth(sysContext: *mut TSS2_SYS_CONTEXT,
                                  nvIndex: TPMI_RH_NV_INDEX,
                                  cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                  newAuth: *mut TPM2B_AUTH,
                                  rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                       signHandle: TPMI_DH_OBJECT,
                                       authHandle: TPMI_RH_NV_AUTH,
                                       nvIndex: TPMI_RH_NV_INDEX,
                                       qualifyingData: *mut TPM2B_DATA,
                                       inScheme: *mut TPMT_SIG_SCHEME,
                                       size: UINT16, offset: UINT16)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify_Complete(sysContext: *mut TSS2_SYS_CONTEXT,
                                        certifyInfo: *mut TPM2B_ATTEST,
                                        signature: *mut TPMT_SIGNATURE)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_NV_Certify(sysContext: *mut TSS2_SYS_CONTEXT,
                               signHandle: TPMI_DH_OBJECT,
                               authHandle: TPMI_RH_NV_AUTH,
                               nvIndex: TPMI_RH_NV_INDEX,
                               cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                               qualifyingData: *mut TPM2B_DATA,
                               inScheme: *mut TPMT_SIG_SCHEME, size: UINT16,
                               offset: UINT16, certifyInfo: *mut TPM2B_ATTEST,
                               signature: *mut TPMT_SIGNATURE,
                               rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test_Prepare(sysContext: *mut TSS2_SYS_CONTEXT,
                                            inputData: *mut TPM2B_DATA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test_Complete(sysContext:
                                                 *mut TSS2_SYS_CONTEXT,
                                             outputData: *mut TPM2B_DATA)
     -> TPM_RC;
}
extern "C" {
    pub fn Tss2_Sys_Vendor_TCG_Test(sysContext: *mut TSS2_SYS_CONTEXT,
                                    cmdAuthsArray: *const TSS2_SYS_CMD_AUTHS,
                                    inputData: *mut TPM2B_DATA,
                                    outputData: *mut TPM2B_DATA,
                                    rspAuthsArray: *mut TSS2_SYS_RSP_AUTHS)
     -> TPM_RC;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum printf_type { NO_PREFIX = 0, RM_PREFIX = 1, }
pub type TCTI_LOG_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void,
                                               type_: printf_type,
                                               format:
                                                   *const ::std::os::raw::c_char, ...)
                              -> ::std::os::raw::c_int>;
pub type TCTI_LOG_BUFFER_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(useriData:
                                                   *mut ::std::os::raw::c_void,
                                               type_: printf_type,
                                               buffer: *mut UINT8,
                                               length: UINT32)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TCTI_DEVICE_CONF {
    pub device_path: *const ::std::os::raw::c_char,
    pub logCallback: TCTI_LOG_CALLBACK,
    pub logData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TCTI_DEVICE_CONF() {
    assert_eq!(::std::mem::size_of::<TCTI_DEVICE_CONF>() , 24usize , concat !
               ( "Size of: " , stringify ! ( TCTI_DEVICE_CONF ) ));
    assert_eq! (::std::mem::align_of::<TCTI_DEVICE_CONF>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TCTI_DEVICE_CONF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_DEVICE_CONF ) ) . device_path as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_DEVICE_CONF ) ,
                "::" , stringify ! ( device_path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_DEVICE_CONF ) ) . logCallback as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_DEVICE_CONF ) ,
                "::" , stringify ! ( logCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_DEVICE_CONF ) ) . logData as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_DEVICE_CONF ) ,
                "::" , stringify ! ( logData ) ));
}
impl Clone for TCTI_DEVICE_CONF {
    fn clone(&self) -> Self { *self }
}
impl Default for TCTI_DEVICE_CONF {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn InitDeviceTcti(tctiContext: *mut TSS2_TCTI_CONTEXT,
                          contextSize: *mut usize,
                          config: *const TCTI_DEVICE_CONF) -> TSS2_RC;
}
extern "C" {
    #[link_name = "printfFunction"]
    pub static mut printfFunction:
               ::std::option::Option<unsafe extern "C" fn(type_: printf_type,
                                                          format:
                                                              *const ::std::os::raw::c_char, ...)
                                         -> ::std::os::raw::c_int>;
}
extern "C" {
    pub fn PlatformCommand(tctiContext: *mut TSS2_TCTI_CONTEXT,
                           cmd: ::std::os::raw::c_char) -> TSS2_RC;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TCTI_SOCKET_CONF {
    pub hostname: *const ::std::os::raw::c_char,
    pub port: u16,
    pub logCallback: TCTI_LOG_CALLBACK,
    pub logBufferCallback: TCTI_LOG_BUFFER_CALLBACK,
    pub logData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TCTI_SOCKET_CONF() {
    assert_eq!(::std::mem::size_of::<TCTI_SOCKET_CONF>() , 40usize , concat !
               ( "Size of: " , stringify ! ( TCTI_SOCKET_CONF ) ));
    assert_eq! (::std::mem::align_of::<TCTI_SOCKET_CONF>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( TCTI_SOCKET_CONF ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_SOCKET_CONF ) ) . hostname as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_SOCKET_CONF ) ,
                "::" , stringify ! ( hostname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_SOCKET_CONF ) ) . port as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_SOCKET_CONF ) ,
                "::" , stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_SOCKET_CONF ) ) . logCallback as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_SOCKET_CONF ) ,
                "::" , stringify ! ( logCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_SOCKET_CONF ) ) . logBufferCallback
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_SOCKET_CONF ) ,
                "::" , stringify ! ( logBufferCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TCTI_SOCKET_CONF ) ) . logData as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( TCTI_SOCKET_CONF ) ,
                "::" , stringify ! ( logData ) ));
}
impl Clone for TCTI_SOCKET_CONF {
    fn clone(&self) -> Self { *self }
}
impl Default for TCTI_SOCKET_CONF {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn InitSocketTcti(tctiContext: *mut TSS2_TCTI_CONTEXT,
                          contextSize: *mut usize,
                          config: *const TCTI_SOCKET_CONF, serverSockets: u8)
     -> TSS2_RC;
}
extern "C" {
    pub fn SendSessionEndSocketTcti(tctiContext: *mut TSS2_TCTI_CONTEXT,
                                    tpmCmdServer: UINT8) -> TSS2_RC;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __locale_data {
    pub _address: u8,
}
impl Clone for __locale_data {
    fn clone(&self) -> Self { *self }
}
